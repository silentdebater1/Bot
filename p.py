# -*- coding: utf-8 -*-
import os
import sys
import json
import random
import re
import base64
import shutil
from io import BytesIO

import aiohttp
import nest_asyncio

from flask import Flask
from threading import Thread
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
from telegram.helpers import mention_html, escape_markdown
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
)

import logging

# Logger setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
nest_asyncio.apply()

# ------------------------------
# Flask Keep-Alive (á€¡á€›á€„á€ºá€†á€¯á€¶á€¸ á€‘á€Šá€·á€º)
# ------------------------------
app_flask = Flask('')

@app_flask.route('/')
def home():
    return "Bot is running"

def run_flask():
    app_flask.run(host='0.0.0.0', port=10000)

def keep_alive():
    t = Thread(target=run_flask)
    t.start()

keep_alive()


TOKEN = "8482426081:AAFIgfRMBj4KdIqGSlxtjPCbatocUl_Gf-s"
OWNER_USERNAME = "@Problem_Zenki"
OWNER_ID = 7808603044
CHANNEL_ID = -1002153191249  
GROUP_ID = -1001234567890  # á€á€„á€·á€º group id
GROUP_ID_FILE = "group_id.txt"
LOG_FILE = "send__command_log.json"

# á€–á€­á€¯á€„á€ºá€™á€›á€¾á€­á€›á€„á€º [] á€”á€²á€· á€…á€•á€¼á€®á€¸ á€–á€”á€ºá€á€®á€¸á€‘á€¬á€¸á€™á€šá€º
if not os.path.exists(LOG_FILE):
    with open(LOG_FILE, "w", encoding="utf-8") as f:
        json.dump([], f, ensure_ascii=False, indent=2)

def write_log(entry):
    """log á€–á€­á€¯á€„á€ºá€‘á€²á€€á€­á€¯ entry á€¡á€á€…á€ºá€‘á€Šá€·á€ºá€›á€”á€º"""
    data = []
    if os.path.exists(LOG_FILE):
        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
                if not isinstance(data, list):
                    data = []
        except Exception:
            # JSON corrupted á€–á€¼á€…á€ºá€›á€„á€º reset
            data = []

    # á€¡á€á€…á€ºá€‘á€Šá€·á€º
    data.append(entry)

    # overwrite á€•á€¼á€”á€ºá€á€­á€™á€ºá€¸
    try:
        with open(LOG_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        # Log write fail á€›á€„á€º console á€‘á€²á€™á€¾á€¬á€•á€² print
        print(f"âŒ Log write failed (ignored): {e}")

OWNER_USERNAME_LC = OWNER_USERNAME.lower()

# ====== Owner check (username or user_id support) ======
def is_owner(user) -> bool:
    """
    user: str (username) or int (user_id)
    """
    if isinstance(user, int):
        return user == OWNER_ID
    # assume string username
    username = user.lower()
    owner = OWNER_USERNAME.lower()
    if not username.startswith("@"):
        username = "@" + username
    if not owner.startswith("@"):
        owner = "@" + owner
    return username == owner

# ====== Admin or Owner check (username or user_id support) ======
def is_admin_or_owner(user) -> bool:
    """
    user: str (username) or int (user_id)
    """
    if isinstance(user, int):
        return user in ADMINS or user == OWNER_ID

    # assume string username
    username = user.lower()
    if not username.startswith("@"):
        username = "@" + username

    owner = OWNER_USERNAME.lower()
    if not owner.startswith("@"):
        owner = "@" + owner

    # username á€€á€­á€¯ owner á€”á€²á€· admin list á€”á€¾á€…á€ºá€á€¯á€™á€¾á€¬á€…á€…á€ºá€™á€šá€º
    return username == owner or username in [a.lower() if a.startswith("@") else "@" + a.lower() for a in ADMINS]

import os
import json
from telegram import Update
from telegram.ext import ContextTypes

GROUP_FILE = "groups.json"

# Default group IDs
DEFAULT_GROUPS = [-1002865590125, -1002657431146, -1002672386358, -1002824406941, -1002675388193, -1002755786073, -1002738605833, -1002547705170, -1002795643369, -1002771530526, -1002580680497, -1002701821014, -1002820650848, -1002710658751, -1002868385707, -1002503242420, -1002735060262, -1002727701149, -1002395104351, -1002644990249, -1002501251323, -1002890348514, -1002700395342, -1002245726777, -1002839921926, -1002742279731, -1002581240932, -1002451207038, -1002382639919, -1002852916926, -1002750172014, -1002718115945, -1002763542464, -1002480189856, -1002696856147, -1002346192734, -1002411525875, -1002826307669, -1002726412621, -1002824961844, -1002890570887, -1002639007736, -1002877604519, -1002745247518, -1002818498085, -1002628603499, -1002893790114, -1002812125414, -1002650483260, -1002621335940, -1002810043325, -4820221622, -1002876540055, -1002838027756, -1002752989480, -1002308878421, -1002681102796, -1002621941130, -1002687419152, -1002864233212, -1002898561329, -1002778748175, -1002683738469, -1002858246104, -1002772857451, -1002867329830, -1002834635993, -1002583561858, -1002631961579, -4871602130, -4897752991, -1002703886615, -1002758113427, -1002624551104, -1002818222148, -1002797887221, -1002881583833, -1002807982387, -1002763526901, -1002614271947, -1002892816171, 7755534644, -1002821769781, 7607539696, -1002656108167, -1002603100242, 7808603044, -1002593299442, -1002472070606, -1002592108582, -1002633878878, -1002771611372, -1002201530021, -1002577864831, -1002740744429, -1002570276680, -1002849463338, -1002591702066, -1002830926696, -1002564210949, -1002591000643, -1002576402690, -1002509878128, -1002826455971, -1002780953313, -1002716913989, -1002758630985, -1002704709610, -1002596171033, -1002747161578, -1002717637302, -1002747253489, -1002765992898, -1002622585710, -1002890538529, -1002398139830, -4772521804, -1002573154837, -1002878408879, -1002309148006, -1002205079622, -1002652584138, -1002725853298, -1001949068259, -1002869336591, -1002671147236, -1002734323078, -1002190347628, -1002857142069, -1002324079192, -1002406264765, -4937208814, -1002772359312, -1002654920940, -1002734452064, -4887582355, 7087036629, -1002730602322, -1002864139546, -1002751439125, -1002577623103, -1002498484332, -1002709195487, -1002842963473, -1002529065189, -1002771296392, -1002592906369, -1002894229931, -1002295053991, -1002618443476, -1002739125761, -1002827602957, -1002713782153, -1002414209901, -1002800303676, -1002326884710, -1002491117885, -1002635439579, -1002545993176, -1002301869653, -1002096289525, -1002724501223, -1002796048586, -1002831809805, -1002573524183, -1002577291773, -1002889520987, -1002799767390, -4919638128, -1002702187228, -1002573904451, -1002646804443, -4805843902, -1002787704857, -1002709092054, -1002750255671, -1002577648098, -1002708644974, -1002673203721, -1002743682689, -1002986975513, -1002951794415, -1002504760087, -1003097164215, -1003081616517, -1002795685243, -1002125647182, -1002866432784, -1002938676471, -1002968121790, -1002658385668, -1002911541411, -1002279822338, -1002950245763, -1002713008036, -1003085237707, -1002824508905, -4630819086, -1002938698169, -1002861608525, -1003040830051, -1002817210705, -1002434033282, -1002981912200, -1002540907874, -1002788254017, -1003018894582, -4864494804, -1002699084965, -1002801244197, -1002722471816, -1002785683686, -1002286495588, -1002911343962, -1002338895815, -1002910504248, -1003065108734, -1002782005195, -1002255958444, -1002205843914, -1002449294887, -2072611715816, -1002428137194, -1002973414919, -1002890033784, -1002716239968, -1002293679861, -1002949193714, -1002799511465, -1003023300764, -1002824362038, -1002666139043, -1003001463419, -1003068030176, -1002843181638, -1002894903690, -1002979953065, -1002771672098, -1002185477216, -1002652702141, -1002941310033, -1002970420794, -1002831944993, -1002690641077, -1002746632414, -1002592005155, -1002466893840, -1002600654627, -1002652902895, -1003032183009, -1002735864917, -1002849286812, -1003073997858, -1003041173303, -4845601955, -4878142908, -4979297481, -4793125753, -4608995034, -1002707294835, -4857339063, -1003025814692, -1002685346969, -1002519151206, -1002388195082, -1002737928314, -1002821272380, -4872637656, -1002441931582, 6968555935, -4705685044, -1002932949888, -1002606961711, -1002628254044, -1002102612730, -1003080568125, -1002376623993, -1002916016762, -1002929149591, -1002768589551, -1002425123917, -1002870698910, -1002773564979, -1002932007609, -1002681748275, -1002812526269, -1002866086589, -1003073554196, -1003063764830, -1002868441786, -1002433958632, -1003068042736, -1003051579994, -1003064042413, -1002522373467, -4655504268, -1003096799403, -1002954003524, -1002721900620, -1002642839074, -1002935775613, -1002528508777, -1002026488809, -1002885780369, -1002952126547, -1002521472891, -1003017098951, -1002974614011, -1003028658320, -1002567281631, -1002715567690, -1002678478572, -1002983835682, -1002909939459, -1002473493627, -1003050621691, -1002983586892, -1002720368760, -1002927776390, -4835633470, -1003056189341, -1003065171399, -1002866488253, -1002584002035, -1002592513107, -1002580968651, -1002266906213, -1003073169953, -1002593681049, -1002564713380, -1002974550934, -1002482955880, -1002848946280, -1002944407235, -1002946349731, -4778277132, -1003015252792, -1002990813316, -1002990129012, -1002936650144, -1002966001659, -1002882504722, -1003068090929, -1003027976926, -1002468017945, -1002991161758, -1002970941346, -1002226197075, -1002553264392, -1002688832656, -4977222381, -4699134136, -1002596847454, -1002833269638, -1002802907224, -1002828753933, -1002256551617, -1003051279966, -1002572878642, -1002995035445, -1003027017599, -1002879654684, -1003011767577, -1002757484587, -1003039783110, -1002837170392, -1003047990812, -1003034508659, -1002696428701, -1002782243851, -4987439504, -1003020089684, -1002558944869, -1002979065100, -1002934732290, -1002576937996, -1002898922725, -1003065347415, -1002650892812, -1002583174919, -1002845891376, -1002581024117, -1002912541886, -1002527006063, -1002075433590, -1002911199365]
# Group ID á€á€½á€±á€€á€­á€¯ á€–á€­á€¯á€„á€ºá€‘á€²á€€á€”á€± Load
def load_groups():
    if not os.path.exists(GROUP_FILE):
        return []
    with open(GROUP_FILE, "r") as f:
        return json.load(f)

# Group ID á€¡á€á€…á€ºá€…á€¬á€›á€„á€ºá€¸á€œá€¯á€¶á€¸á€€á€­á€¯ overwrite á€œá€¯á€•á€º
def save_groups(group_ids):
    with open(GROUP_FILE, "w") as f:
        json.dump(group_ids, f, indent=2)

# Group ID á€á€…á€ºá€á€¯á€á€»á€„á€ºá€¸á€…á€®á€‘á€Šá€·á€ºá€•á€¼á€®á€¸ á€á€­á€™á€ºá€¸
def save_group_id(group_id):
    group_ids = load_groups()
    if group_id not in group_ids:
        group_ids.append(group_id)
        save_groups(group_ids)

# Default group ID á€…á€¬á€›á€„á€ºá€¸á€€á€­á€¯ á€–á€­á€¯á€„á€ºá€‘á€²á€á€­á€¯á€· á€…á€á€„á€ºá€‘á€Šá€·á€º
def init_groups():
    save_groups(DEFAULT_GROUPS)
    print(f"{len(DEFAULT_GROUPS)} group IDs á€€á€­á€¯ {GROUP_FILE} á€‘á€²á€á€­á€¯á€· á€…á€á€„á€ºá€‘á€Šá€·á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®á‹")

# Group ID á€€á€­á€¯ á€á€½á€„á€ºá€¸á€–á€­á€¯á€· handler (Bot á€á€½á€±á€™á€¾á€¬á€á€¯á€¶á€¸á€›á€”á€º)
async def track_group_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type in ["group", "supergroup"]:
        save_group_id(chat.id)

ADMIN_FILE = "admins.json"

DEFAULT_ADMINS = [
    "@Anyartar16",
    "@Auutyofi",
    "@Bby_Ava_Lvr",
    "@Bby_rixx",
    "@Bhonea_z_0_9",
    "@Bshghsj",
    "@CO2_Depress",
    "@Can_you_call_me_jei_jei",
    "@Car_Car32",
    "@Complex_Dixz",
    "@DaxxGon",
    "@Dbngaduu",
    "@Deborah_is_not_your_girlfriend",
    "@Fpzzzll",
    "@God_Of_Zenn",
    "@Hmue_Offical",
    "@I_still_love_someone",
    "@Idwlfa1",
    "@Joy_Fav_Lyushi",
    "@JusT_caLL_MiRo",
    "@Just_call_me_Nytheris",
    "@Ka_zu_ki_official_acc",
    "@Kalarrlayy",
    "@Kenneth_thK",
    "@Ko_Ahtr",
    "@Kukuisvilain",
    "@Kyaw_gyi_KK",
    "@LEON77730",
    "@Lada_yine",
    "@Leo_7_x",
    "@Leonar3384",
    "@Lord_Brandon",
    "@Lord_YatKha",
    "@Maimai11345",
    "@Marktz3",
    "@Mg_Mg_Q",
    "@Min_Sir_AungBa",
    "@Mioo_is_my_fav_girl",
    "@Miro_is_not_for_u",
    "@Mr_vladimiar",
    "@Myat_2222",
    "@Mzz_kol",
    "@Natalieglovevr",
    "@Nga_Dan",
    "@No_Counter_Offical_kiro",
    "@Normal_People_Ryannex",
    "@Not_your_stepmother",
    "@Nrkkcl",
    "@Nytheris_Fav_Nann_Nann",
    "@OfcTinKyaw",
    "@Ofcnohtan",
    "@Offical_Ble",
    "@Official_Ethan_77",
    "@Offshino",
    "@Polouniumi209",
    "@Pro_vnz",
    "@Problem_Zenki",
    "@Problem_Zenkii",
    "@RainnBuiltDifferently",
    "@Rainn_CrimsonStanza",
    "@Real_archimedes",
    "@Ri_ppo_goat",
    "@Rovian_official",
    "@SOUJRIO",
    "@Scamer_Koi",
    "@Schicklgruber_Jutaio_mayfav",
    "@Sir_William111",
    "@Super_mario_offical",
    "@Super_soilder_Khoon",
    "@Ta_Yo_KaMa",
    "@Tarzanbooml",
    "@Taurus_offical_Lmp",
    "@Thapayrthiiiiii",
    "@Wxylord_Ngayell",
    "@X1zynx",
    "@XoFox_Kory",
    "@YOUR_FATHER_DK",
    "@Yoon_ofc",
    "@Z_for_T",
    "@cylorrd_nohtan",
    "@gabe_offical",
    "@gutznia",
    "@kal_sein_ma",
    "@kia_no_counter",
    "@kiro_is_not_for_u",
    "@kmklkee",
    "@kvy_offlice4",
    "@mYnAmEiSnOli",
    "@markneil1",
    "@nan_mu_dyar_lwin",
    "@ntzn1xx",
    "@official_Riyo_2006",
    "@official_nan_ju",
    "@olumr69",
    "@super_soilder_khoon",
    "@tayoke_kalar",
    "@urf4vv_z",
    "@whysosadwilli",
    "@wxyryden",
    "@yep_im_Tao",
    "@yeslamsarki",
    "â€Œ@David_Official_No_Counter"
]

# list -> set á€•á€¼á€±á€¬á€„á€ºá€¸á€•á€¼á€®á€¸ lowercase á€•á€¼á€±á€¬á€„á€ºá€¸
ADMIN_USERNAMES = {a.lower() for a in DEFAULT_ADMINS}

ADMINS_LC = ADMIN_USERNAMES  # á€’á€®á€¡á€á€­á€¯á€„á€ºá€¸á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€•á€«á€á€šá€º

ACTIVE_ATTACKS = {}
AUTO_DIE = {}
auto_replies = [ "á€•á€¼á€á€¬á€”á€¬á€†á€­á€¯á€á€²á€·á€á€á€„á€ºá€†á€²á€›á€„á€ºá€™á€„á€ºá€¸á€á€­á€¯á€·á€„á€¼á€­á€™á€ºá€á€¶á€›á€™á€šá€ºá€†á€­á€¯á€á€¬á€™á€„á€ºá€¸á€á€­á€¯á€·á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€¼á€®á€¸á€™á€á€„á€ºá€•á€±á€¸á€‘á€¬á€¸á€˜á€°á€¸á€œá€¬á€¸", "á€™á€„á€ºá€¸á€¡á€–á€±á€€á€•á€­á€¯á€€á€ºá€†á€¶á€œá€­á€¯á€œá€­á€¯á€·á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€„á€«á€”á€²á€·á€•á€±á€¸á€œá€­á€¯á€¸á€•á€¼á€®á€¸á€™á€„á€ºá€¸á€‘á€½á€€á€ºá€œá€¬á€á€¬á€œá€±á€á€¬á€¸á€™á€­á€¯á€€á€º", "á€™á€„á€ºá€¸á€…á€±á€¬á€ºá€–á€¬á€á€Šá€ºá€™á€•á€±á€¸á€˜á€¯á€•á€«á€œá€¬á€¸á€œá€½á€á€ºá€œá€­á€¯á€€á€ºâ€Œá€±á€”á€¬á€ºá€¡á€›á€¾á€„á€ºá€á€á€„á€ºá€•á€¼á€á€¬á€”á€¬á€†á€®á€€á€­á€¯á€œá€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€­á€¯á€„á€«á€·á€†á€®á€œá€­á€„á€ºá€€á€»á€½á€”á€ºá€¡á€–á€¼á€…á€ºá€á€…á€¬á€¸á€”á€±á€›á€á€šá€º", "á€˜á€¬á€˜á€¬á€á€±á€¬á€„á€ºá€¸á€•á€”á€ºá€á€šá€ºá€Ÿá€¯á€á€ºá€œá€¬á€¸ á€á€¼á€±á€‘á€±á€¬á€€á€ºá€‘á€­á€á€±á€¬á€„á€ºá€¸á€•á€”á€ºá€œá€±", "á€Ÿá€€á€ºá€€á€œá€…á€ºá€á€½á€±á€¸á€™á€„á€ºá€¸á€€á€œá€…á€ºá€€á€¼á€®á€¸á€€á€”á€¾á€±á€¸á€€á€½á€±á€¸á€”á€±á€á€¬á€˜á€²Typingá€†á€­á€¯á€›á€„á€ºá€á€±á€¬á€·á€œá€­á€•á€ºá€‚á€½á€„á€ºá€¸á€‘á€¯á€™á€¾á€•á€¼á€®á€¸á€™á€šá€·á€ºá€€á€±á€¬á€„á€º", "á€„á€«á€›á€²á€·á€…á€¬á€€á€­á€¯á€á€»á€±á€•á€–á€­á€¯á€·á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€¼á€®á€¸á€€á€™á€á€„á€ºá€•á€±á€¸á€‘á€¬á€¸á€˜á€°á€¸á€œá€±á€€á€½á€¬", "á€™á€„á€ºá€¸á€…á€€á€±á€¸á€€á€’á€«á€•á€²á€œá€¬á€¸á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€€á€­á€¯á€€á€ºá€¡á€¯á€”á€ºá€¸", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€€á€€á€¼á€±á€¬á€€á€ºá€€á€”á€ºá€€á€”á€ºá€á€¬á€œá€¬á€¸á€¡á€€á€ºá€á€¬á€€", "á€˜á€¬á€á€½á€±á€•á€¼á€±á€¬á€”á€±á€á€¬á€’á€®á€…á€±á€¬á€€á€ºá€›á€°á€¸á€‚á€±á€«á€€á€ºá€á€®á€¸á€”á€²á€·á€€á€á€±á€¬á€·", "á€•á€¼á€±á€¬á€á€»á€„á€ºá€á€¬á€á€½á€±á€•á€¼á€±á€¬á€•á€®á€á€…á€ºá€€á€­á€¯á€šá€ºá€á€±á€¬á€„á€ºá€œá€½á€á€ºá€•á€»á€±á€¬á€ºá€”á€±á€á€¬á€œá€¬á€¸á€…á€±á€¬á€€á€ºá€›á€°á€¸á€œá€±á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€™á€„á€ºá€¸á€€á€­á€¯á€€á€»á€•á€ºá€™á€•á€¼á€Šá€·á€ºá€˜á€°á€¸á€œá€­á€¯á€·á€•á€¼á€±á€¬á€›á€„á€ºá€›á€„á€ºá€€á€½á€²á€™á€œá€¬á€¸", "á€™á€„á€ºá€¸á€”á€¬á€™á€Šá€ºá€€á€™á€¡á€±á€¸á€œá€­á€¯á€¸á€•á€±á€«á€·", "á€™á€„á€ºá€¸á€€á€˜á€¬á€œá€­á€¯á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€–á€¼á€…á€ºá€”á€±á€›á€á€¬", "á€šá€»á€±á€¬á€„á€·á€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€€á€­á€¯á€„á€«á€™á€±á€¸á€”á€±á€á€šá€º", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€˜á€šá€ºá€•á€¼á€±á€¸á€™á€¾á€¬á€•á€¼á€”á€ºá€œá€¬á€€á€­á€¯á€€á€º", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€á€±á€¬á€á€®á€¸á€•á€»á€±á€¬á€·á€á€»á€€á€ºá€€á€á€±á€¬á€·á€‚á€½á€±á€¸á€á€®á€¸á€œá€¬á€•á€²", "á€¡á€¬á€á€®á€¸á€šá€±á€¬á€„á€ºá€á€¬á€œá€»á€¾á€±á€¬á€·á€œá€­á€¯á€€á€ºá€á€±á€¬á€á€¬á€¸á€œá€±ğŸ‘ğŸ¤¨ğŸ¤¨", "Hiá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸", "á€…á€¬á€›á€­á€¯á€€á€ºá€•á€«á€¡á€¯á€”á€ºá€¸á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€¡á€”á€°á€œá€€á€ºá€”á€²á€·á€€á€¯á€œá€¬á€¸á€›á€±", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€¡á€á€¯á€™á€˜á€¬á€€á€­á€¯á€€á€°á€•á€«á€€á€šá€ºá€•á€«á€œá€²ğŸ˜³", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€›á€­á€¯á€€á€ºá€‘á€¬á€¸á€œá€±á€¸á€…á€±á€¬á€€á€ºá€›á€°á€¸", "á€™á€¡á€±á€¸á€œá€­á€¯á€¸á€á€½á€±á€¸á€á€¬á€¸á€”á€¬á€¸á€›á€„á€ºá€„á€«á€·á€á€•á€Šá€·á€º", "á€„á€«á€·á€¡á€™á€­á€”á€·á€ºá€™á€›á€•á€²á€˜á€¬á€€á€­á€¯á€”á€¬á€¸á€á€»á€„á€ºá€á€¬á€œá€²á€á€½á€±á€¸á€™á€á€¬á€¸á€™á€»á€­á€¯á€¸", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€–á€®á€†á€”á€ºá€á€¬á€œá€¬á€¸á€€á€½ğŸ˜¨", "á€™á€€á€­á€¯á€€á€ºá€”á€­á€¯á€„á€ºá€á€±á€¬á€·á€˜á€°á€¸á€œá€¬á€¸á€á€½á€±á€¸á€™á€á€¬á€¸ğŸ˜", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€Šá€±á€¬á€„á€ºá€¸á€”á€±á€•á€®á€œá€¬á€¸", "á€™á€„á€ºá€¸á€œá€€á€ºá€á€½á€±á€€á€¡á€œá€¯á€•á€ºá€€á€¼á€™á€ºá€¸á€œá€¯á€•á€ºá€á€²á€·á€œá€€á€ºá€•á€²á€˜á€¬á€€á€­á€¯á€Šá€±á€¬á€„á€ºá€¸á€á€»á€„á€ºá€šá€±á€¬á€„á€ºá€†á€±á€¬á€„á€ºá€á€¬á€œá€²", "á€Ÿá€”á€ºá€•á€²á€›á€¾á€­á€á€šá€ºâ€Œá€™á€¬á€”á€ºá€™á€›á€¾á€­á€˜á€°á€¸á€™á€„á€ºá€¸á€œá€­á€¯á€á€½á€±á€¸á€€ğŸ˜›", "á€˜á€¬á€†á€„á€ºá€á€¼á€±á€á€½á€±á€œá€¬á€•á€±á€¸á€”á€±á€á€¬á€™á€á€”á€¬á€¸á€˜á€°á€¸á€„á€«á€€", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€€á€¼á€±á€¬á€„á€ºá€á€±á€¬á€„á€ºá€á€±á€¬á€„á€ºá€”á€²á€·á€›á€°á€¸á€”á€±á€á€¬á€œá€¬á€¸", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€€á€­á€¯á€€á€ºá€œá€±á€™á€„á€ºá€¸á€¡á€™á€±á€…á€±á€¬á€€á€ºá€•á€á€ºá€™á€œá€­á€¯á€·á€”á€¬á€¸á€á€¬á€œá€¬á€¸á€™á€„á€ºá€¸á€€", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€á€²á€·á€…á€±á€¬á€€á€ºá€•á€»á€±á€¬á€·á€œá€°á€œá€¬á€¸á€á€½á€±á€¸á€œá€¬á€¸á€™á€„á€ºá€¸á€€á€™á€á€²á€€á€½á€²á€á€±á€¬á€·á€˜á€°á€¸", "á€™á€„á€ºá€¸á€™á€­á€˜á€„á€«á€œá€­á€¯á€¸á€„á€«á€œá€­á€¯á€¸á€™á€½á€±á€¸á€‘á€¬á€¸á€á€²á€·á€á€¬á€¸á€•á€²á€™á€„á€ºá€¸á€€", "á€™á€„á€ºá€¸á€¡á€™á€±á€„á€«á€œá€­á€¯á€¸á€œá€­á€¯á€€á€ºá€œá€­á€¯á€·á€™á€„á€ºá€¸á€€á€„á€«á€·á€á€¬á€¸á€–á€¼á€…á€ºá€€á€±á€¬á€œá€¬á€¸á€á€±á€¬á€á€®á€¸ğŸ¤‘", "á€á€±á€¬á€á€®á€¸á€™á€”á€¬á€¸á€”á€²á€·á€œá€±á€€á€­á€¯á€€á€ºá€¡á€½á€™á€ºá€¸", "á€•á€»á€±á€¬á€·á€œá€­á€¯á€€á€ºá€á€¬á€€á€½á€¬á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€’á€°á€’á€°á€’á€”á€ºá€’á€”á€ºá€€á€±á€¬á€„á€º", "á€á€­á€•á€«á€•á€¼á€®á€á€­á€•á€«á€•á€¼á€®á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€†á€­á€¯á€á€¬", "á€Ÿá€±á€·á€›á€±á€¬á€„á€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸á€¡á€á€¯á€™á€¾á€€á€°á€•á€«á€€á€šá€ºá€•á€«á€’á€°á€•á€«á€’á€”á€ºá€•á€«á€œá€¯á€•á€ºá€”á€±á€á€¬á€œá€¬á€¸á€™á€»á€€á€ºá€”á€¾á€¬á€œá€­á€¯á€™á€»á€€á€ºá€”á€¾á€¬á€›á€„á€«á€·á€˜á€±á€¬á€¡á€á€„á€ºá€¸á€€á€•á€ºá€™á€•á€¼á€®á€¸á€™á€¾á€¡á€á€¯á€˜á€¬á€•á€¼á€”á€ºá€€á€­á€¯á€€á€ºá€á€»á€„á€ºá€”á€±á€á€¬á€œá€Šá€ºá€¸á€Ÿá€±á€·á€›á€±á€¬á€„á€ºá€á€½á€±á€¸á€á€°á€á€±á€¬á€„á€ºá€¸á€…á€¬á€¸", "á€›á€¯á€•á€ºá€†á€­á€¯á€¸á€™á€á€¬á€¸á€á€±á€á€»á€„á€ºá€œá€­á€¯á€·á€œá€¬á€¸", "á€†á€›á€¬á€á€á€„á€ºá€•á€¼á€á€¬á€”á€¬á€€á€­á€¯á€¡á€²á€·á€œá€­á€¯á€€á€•á€ºá€á€­á€¯á€¸á€œá€±á€¸á€˜á€±á€¬á€™á€›á€¯á€¶á€”á€²á€·á€á€±á€¬á€·á€™á€›á€˜á€°á€¸", "á€™á€„á€ºá€¸á€€á€œá€°á€á€€á€¬á€˜á€±á€¬á€™á€œá€¬á€¸á€˜á€¬á€œá€­á€¯á€·á€›á€±á€¬á€á€¬á€œá€²", "á€œá€½á€šá€ºá€œá€­á€¯á€€á€ºá€á€¬á€€á€½á€¬á€¡á€”á€­á€¯á€„á€ºá€šá€°á€™á€­á€•á€¼á€”á€ºá€•á€®ğŸ˜", "á€¡á€²á€·á€œá€±á€¬á€€á€ºá€‡á€”á€²á€·á€™á€”á€­á€¯á€„á€ºá€á€±á€¸á€˜á€°á€¸á€™á€„á€ºá€¸á€„á€«á€·á€€á€­á€¯", "á€€á€¼á€­á€¯á€¸á€…á€¬á€¸á€¡á€¯á€”á€ºá€¸á€á€¬á€¸á€–á€±á€¬á€€á€ºá€œá€­á€¯á€á€±á€¸á€á€šá€º", "á€šá€»á€±á€¬á€„á€·á€ºá€¡á€€á€­á€¯á€€á€ºá€Šá€¶á€·á€á€²á€·á€á€½á€±á€¸á€˜á€šá€ºá€”á€±á€›á€¬á€á€„á€ºá€•á€¯á€”á€ºá€¸á€•á€¼á€”á€ºá€•á€®á€œá€²", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€™á€€á€­á€¯á€€á€ºá€”á€­á€¯á€„á€ºá€á€±á€¬á€·á€˜á€°á€¸á€œá€¬á€¸", "á€™á€„á€ºá€¸á€œá€±á€¬á€€á€ºá€•á€»á€±á€¬á€·á€á€¬á€™á€„á€ºá€¸á€•á€²á€›á€¾á€­á€á€šá€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸", "á€¡á€¯á€”á€ºá€¸á€™á€…á€¬á€¸á€”á€²á€·á€á€±á€¬á€á€®á€¸á€›á€¯á€”á€ºá€¸á€™á€¾á€¬á€á€¬á€†á€€á€ºá€›á€¯á€”á€ºá€¸", "á€€á€¼á€±á€¬á€€á€ºá€”á€±á€á€¬á€œá€¬á€¸á€™á€„á€ºá€¸á€€", "á€˜á€¬á€œá€­á€¯á€·á€€á€¼á€±á€¬á€€á€ºá€•á€¼á€”á€±á€á€¬á€œá€²á€á€½á€±á€¸á€œá€±á€¸", "á€™á€»á€€á€ºá€”á€¾á€¬á€„á€šá€ºá€œá€±á€¸á€”á€²á€·á€¡á€á€”á€¬á€¸á€á€¶á€á€±á€¬á€·á€™á€¬á€œá€¬á€¸", "á€á€±á€¸á€á€±á€¸á€€á€€á€­á€¯á€€á€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€…á€®á€€á€¡á€”á€¶á€™á€€á€±á€¬á€„á€ºá€¸á€˜á€°á€¸", "á€á€½á€±á€¸á€”á€¶á€‘á€½á€€á€ºá€”á€±á€á€šá€ºá€á€½á€±á€¸á€™á€á€¬á€¸á€™á€„á€ºá€¸á€€", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€˜á€šá€ºá€€á€­á€¯á€•á€¼á€±á€¸á€™á€¬", "á€á€±á€¬á€á€¬á€¸á€€á€­á€¯á€€á€ºá€•á€«á€¡á€¯á€”á€ºá€¸á€¡á€šá€¬á€¸á€™á€•á€¼á€±á€–á€¼á€…á€ºá€”á€±á€á€šá€º", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€›á€±á€™á€„á€ºá€¸á€›á€¯á€”á€ºá€¸á€€á€”á€ºá€”á€±á€›á€•á€®á€œá€¬á€¸á€Ÿ", "á€™á€„á€ºá€¸á€™á€±á€…á€•á€á€½á€±á€á€„á€ºá€•á€¼á€±á€¬á€”á€±á€á€¬á€œá€¬á€¸á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸", "á€¡á€±á€¸á€¡á€²á€·á€á€±á€¬á€·á€™á€„á€ºá€¸á€€á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€•á€±á€«á€·á€Ÿá€¯á€á€ºá€œá€¬á€¸", "á€¡á€›á€¾á€¯á€¶á€¸á€á€™á€¬á€¸á€†á€›á€¬á€•á€¼á€á€¬á€”á€¬á€€á€­á€¯á€¡á€›á€¾á€¯á€¶á€¸á€•á€±á€¸á€•á€®á€•á€±á€«á€·", "á€„á€«á€œá€­á€¯á€¸á€™á€á€±á€¬á€á€®á€¸á€›á€¾á€¯á€¶á€¸á€”á€±á€á€±á€¬á€·á€™á€»á€€á€ºá€”á€¾á€¬á€€á€á€…á€ºá€™á€»á€­á€¯á€¸", "á€†á€›á€¬Problemá€¡á€›á€¾á€­á€”á€ºá€¡á€á€«á€€á€á€±á€¬á€ºá€›á€¯á€¶á€™á€»á€€á€ºá€œá€¯á€¶á€¸á€”á€²á€·á€€á€¼á€Šá€·á€ºá€™á€›á€˜á€°á€¸á€Šá€®", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€•á€¼á€”á€ºá€œá€­á€¯á€¸á€á€²á€·á€€á€­á€¯á€™á€±á€€á€­á€¯  á€œá€­á€¯á€¸á€á€¬á€¸á€•á€±á€«á€·á€™á€„á€ºá€¸á€€ğŸ˜³", "á€á€€á€šá€·á€ºá€€á€±á€¬á€„á€º á€€á€­á€¯á€šá€·á€ºá€¡á€™á€±á€€á€­á€¯á€á€°á€™á€»á€¬á€¸á€œá€­á€¯á€¸á€á€­á€¯á€„á€ºá€¸á€›á€á€šá€ºá€œá€­á€¯á€·", "Sorry á€•á€²á€šá€–á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€„á€«á€œá€€á€ºá€œá€½á€”á€ºá€¡á€œá€­á€¯á€¸á€œá€½á€”á€ºá€•á€¼á€®á€™á€„á€ºá€¸á€¡á€™á€±á€›á€¾á€±á€¬á€•á€®", "á€™á€„á€ºá€¸á€•á€«á€¸á€…á€•á€ºá€€á€­á€¯á€–á€¼á€²á€•á€¼á€®á€¸ á€”á€¶á€Ÿá€±á€¬á€„á€ºá€”á€±á€á€šá€º á€¡á€¬á€•á€¯á€á€ºá€…á€±á€¬á€º á€•á€«á€¸á€…á€•á€ºá€€á€­á€¯ á€•á€­á€á€ºá€‘á€¬á€¸á€œá€­á€¯á€€á€º", "á€…á€…á€ºá€˜á€±á€¸á€›á€¾á€±á€¬á€„á€ºá€†á€­á€¯á€•á€¼á€®á€¸ á€›á€•á€ºá€€á€½á€•á€ºá€‘á€²á€™á€¾á€¬ á€•á€­á€¯á€€á€ºá€†á€¶á€œá€­á€¯á€€á€ºá€á€±á€¬á€„á€ºá€¸á€”á€±á€á€šá€º á€™á€á€¬á€€á€±á€¬á€„á€º", "á€˜á€±á€¬á€™", "á€™á€¡á€±á€œá€­á€¯á€¸á€œá€±á€¸á€™á€„á€ºá€¸á€™á€±á€–á€¬á€á€Šá€ºá€™á€†á€­á€¯á€á€¬á€œá€€á€ºá€á€¶á€œá€¬á€¸", "á€Ÿá€¯á€á€ºá€•á€«á€•á€¼á€®á€Ÿá€¯á€á€ºá€•á€«á€•á€¼á€®á€™á€„á€ºá€¸á€™á€±á€–á€¬á€á€Šá€ºá€™á€”á€¬á€›á€±á€¸á€œá€°á€…á€Šá€ºá€›á€²á€·á€œá€¬á€¸", "á€†á€„á€ºá€¸á€›á€²á€á€¬á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€‘á€™á€„á€ºá€¸á€™á€á€»á€€á€ºá€€á€»á€½á€±á€¸á€”á€­á€¯á€„á€ºá€–á€°á€¸á€œá€¬á€¸", "á€¡á€›á€¾á€¯á€¶á€¸á€á€™á€¬á€¸á€˜á€¬á€œá€­á€¯á€·á€›á€¾á€¯á€¶á€¸â€Œá€™á€²á€™á€²á€”á€±á€á€¬á€œá€Šá€ºá€¸", "á€„á€«á€œá€­á€°á€¸á€™á€á€¬á€¸á€á€€á€ºá€„á€¼á€­á€™á€ºá€€á€¯á€á€ºá€”á€±á€œá€¾á€á€»á€‰á€ºá€œá€¬á€¸", "á€™á€”á€­á€¯á€„á€ºá€›á€„á€ºá€á€±á€¬á€· left the group á€á€¬á€œá€¯á€•á€ºá€œá€­á€¯á€€á€ºá€á€±á€¬á€·á€Šá€®á€›á€±", "á€Ÿá€¬á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€á€¬á€á€€á€šá€ºá€–á€¼á€…á€ºá€”á€­á€¯á€„á€ºá€œá€­á€¯á€·á€œá€¬á€¸", "á€˜á€¬á€œá€­á€¯á€·á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€­á€¯á€á€¶á€•á€¼á€±á€¬á€”á€±á€›á€á€¬á€œá€Šá€ºá€¸", "á€”á€¬á€¸á€™á€œá€Šá€ºá€˜á€°á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€á€²á€·á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€á€½á€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€á€²á€·á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€á€½á€±á€€á€­á€¯á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€…á€¯á€¶á€›á€¾á€„á€ºá€¸á€•á€¼á€•á€±á€¸á€•á€«", "á€¡á€™á€¾á€”á€ºá€á€›á€¬á€¸á€›á€²á€·á€˜á€€á€ºá€á€±á€¬á€ºá€á€¬á€¸á€†á€­á€¯á€›á€„á€ºá€™á€„á€ºá€¸á€¡á€™á€±á€„á€«á€¡á€™á€¾á€”á€ºá€á€€á€šá€ºá€œá€­á€¯á€¸á€á€¬á€á€”á€ºá€á€¶á€•á€«", "á€™á€„á€ºá€¸á€…á€±á€¬á€€á€ºá€á€½á€€á€ºá€˜á€¬á€œá€­á€¯á€·á€™á€²á€”á€±á€á€¬", "á€„á€«á€œá€­á€¯á€¸á€™á€…á€±á€¬á€€á€ºá€•á€±á€«á€€á€¼á€®á€¸á€á€…á€ºá€šá€±á€¬á€€á€ºá€‘á€²á€˜á€¬á€á€±á€•á€¼á€±á€¬", "á€€á€±á€¬á€„á€ºá€¸á€•á€«á€•á€¼á€®á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€•á€¼á€®", "á€„á€«á€…á€­á€á€ºá€Šá€…á€ºá€”á€±á€á€šá€ºá€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€œá€®á€¸á€…á€¯á€•á€ºá€™á€€á€»á€½á€™á€ºá€¸á€œá€­á€¯á€·", "á€†á€€á€ºá€€á€­á€¯á€€á€ºá€•á€±á€¸á€•á€«á€˜á€±á€¬á€™á€›á€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€¡á€á€¯á€˜á€¡á€†á€„á€ºá€•á€¼á€±á€›á€²á€·á€œá€¬á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€œá€°á€™á€²", "á€Ÿá€±á€¸á€¡á€›á€¾á€¯á€¶á€¸á€á€™á€¬á€¸á€œá€€á€ºá€•á€”á€ºá€¸á€€á€»á€”á€±á€á€¬á€œá€¬á€¸", "á€™á€á€­á€á€»á€„á€ºá€˜á€°á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€­á€¯ á€™á€„á€ºá€¸á€‰á€®á€¸á€œá€±á€¸á€œá€­á€¯á€¸á€”á€±á€•á€¼á€®", "á€™á€á€­á€á€»á€„á€ºá€˜á€°á€¸á€€á€½á€¬á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€œá€­á€¯á€€á€º", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€˜á€¬á€á€±á€•á€¼á€±á€¬", "á€œá€®á€¸á€•á€²á€†á€²á€”á€±á€á€¬á€á€±á€¬á€„á€ºá€¡á€“á€­á€•á€¹á€•á€¬á€šá€ºá€›á€¾á€­á€›á€¾á€­á€†á€²á€á€²á€·á€„á€«á€·á€€á€­á€¯á€¡á€¬á€¸á€€á€»á€…á€™á€ºá€¸á€•á€«á€Ÿ", "á€œá€°á€á€€á€¬á€¸á€œá€­á€¯á€¸á€á€¶á€›á€á€²á€·á€¡á€™á€±á€€á€”á€±á€™á€½á€±á€¸á€œá€¬á€á€²á€·á€á€¬á€¸", "á€€á€¼á€½á€€á€ºá€™á€á€¬á€¸", "á€Ÿá€­á€á€ºá€€á€±á€¬á€„á€º", "á€á€±á€™á€šá€ºá€”á€±á€¬á€º", "á€„á€«á€œá€­á€¯á€¸á€™á€á€€á€º", "á€œá€€á€ºá€á€½á€±á€á€¯á€”á€ºá€”á€±á€•á€¼á€®á€¸á€…á€¬á€á€½á€±á€á€±á€¬á€„á€ºá€™á€™á€¾á€”á€ºá€á€±á€¬á€·á€•á€«á€œá€¬á€¸á€Ÿ", "á€á€¯á€”á€ºá€›á€™á€šá€ºá€œá€± á€™á€„á€ºá€¸á€›á€„á€ºá€†á€­á€¯á€„á€ºá€”á€±á€›á€á€²á€·á€œá€°á€€ Problem  á€œá€±á€Šá€®", "á€™á€”á€±á€·á€á€”á€±á€·á€€á€™á€¾á€†á€­á€¯á€›á€¾á€šá€ºá€‘á€²á€á€„á€ºá€œá€¬á€•á€¼á€®á€¸á€¡á€›á€¾á€„á€ºá€˜á€¯á€›á€„á€ºá€€á€­á€¯á€•á€¯á€”á€ºá€€á€”á€ºá€á€¬á€á€±á€’á€á€ºá€”á€±á€¬á€ºá€á€½á€±á€¸á€›", "á€›á€¯á€€á€¹á€á€†á€­á€¯á€¸á€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€„á€«á€œá€­á€¯á€¸ á€„á€«á€·á€œá€±á€¬á€€á€ºá€¡á€‘á€¬á€™á€€á€»á€œá€­á€¯á€·á€á€­á€¯á€¸á€„á€­á€¯á€”á€±á€á€¬á€œá€¬á€¸", "á€á€€á€šá€·á€ºá€€á€±á€¬á€„á€º á€…á€±á€¬á€€á€ºá€›á€¯á€•á€ºá€†á€­á€¯á€¸", "á€…á€±á€¬á€€á€ºá€¡á€‘á€¬á€€á€»á€”á€Šá€ºá€¸á€á€„á€ºá€•á€±á€¸á€™á€šá€ºá€–á€±á€–á€±á€á€±á€«á€º", "á€œá€®á€¸á€¦á€¸á€”á€¾á€±á€¬á€€á€ºá€”á€²á€·á€á€½á€±á€¸á€™á€€ á€œá€¬á€šá€¾á€¥á€ºá€”á€±á€á€¬", "á€‚á€»á€•á€­á€¯á€¸á€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€¡á€­á€™á€ºâ€Œá€±á€™á€¼á€¬á€„á€ºá€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€€á€¼á€½á€€á€ºá€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€’á€­á€¯á€„á€ºá€†á€­á€¯á€†á€±á€¬á€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€á€½á€±á€¸á€™á€»á€­á€¯á€¸á€á€¯á€¶á€¸á€á€¼á€„á€ºá€”á€±á€á€¬á€á€½á€±á€¸á€™á€€", "á€™á€¡á€±á€œá€­á€¯á€¸á€”á€¬á€‡á€®á€™á€á€¬á€¸", "á€šá€±á€›á€¾á€°á€€á€­á€¯á€¸á€€á€½á€šá€ºá€á€²á€·á€€á€¯á€œá€¬á€¸á€Ÿá€œá€®á€¸á€˜á€²", "á€˜á€¯á€›á€¬á€¸á€á€á€„á€ºá€œá€®á€¸á€€á€»á€½á€±á€¸á€•á€«á€…á€±", "á€™á€„á€ºá€¸á€€á€­á€¯á€€á€±á€¬á€„á€ºá€¸á€á€»á€®á€¸á€•á€±á€¸á€•á€¼á€®á€¸á€–á€„á€ºá€œá€­á€¯á€¸á€™á€¾á€¬á€œá€±á€…á€±á€¬á€€á€ºá€€á€¯á€œá€¬á€¸", "á€Ÿá€­á€á€ºá€á€€á€º á€”á€á€ºá€•á€¼á€Šá€ºá€á€¬á€á€á€­á€¶á€á€¬á€€ á€¡á€›á€¾á€„á€ºá€˜á€¯á€›á€„á€ºá€€á€¼á€½á€œá€¬á€•á€¼á€®á€–á€„á€ºá€œá€­á€¯á€¸á€á€±á€¬á€·á€™á€šá€ºá€Ÿá€™á€„á€ºá€¸á€€á€­á€¯", "á€„á€«á€œá€­á€¯á€¸á€¸á€™á€€á€¯á€œá€¬á€¸á€…á€¬á€‘á€•á€ºá€•á€­á€¯á€·á€›á€„á€ºá€¡á€á€­á€¯á€„á€ºá€¸á€…á€±", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€€á€¡á€á€­á€¯á€„á€ºá€¸á€…á€±á€œá€­á€¯á€·á€á€”á€ºá€á€¶á€á€¬á€Ÿá€„á€­á€„á€­", "á€á€€á€ºá€™á€á€¬á€¸á€á€±á€¬á€„á€ºá€¸á€•á€”á€ºá€œá€±á€œá€®á€¸á€€á€¼á€Šá€·á€ºá€”á€±á€á€¬á€œá€¬á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€á€½á€±á€¸á€†á€²á€›á€„á€ºá€„á€¼á€­á€™á€ºá€á€¶á€á€¯á€”á€ºá€™á€€á€­á€¯á€€á€ºá€”á€²á€·", "á€–á€„á€ºá€œá€­á€¯á€¸á€…á€á€”á€ºá€¸á€€á€•á€« á€Šá€®á€›á€±á€–á€„á€ºá€œá€­á€¯á€¸á€•á€«á€›á€…á€±", "á€–á€„á€ºá€œá€­á€¯á€¸á€á€½á€„á€·á€ºá€•á€¼á€¯á€•á€«", "á€™á€¡á€±á€œá€­á€¯á€¸á€€á€œá€²á€”á€²á€”á€²á€•á€²á€…á€›á€á€±á€¸á€á€šá€ºá€œá€±á€¬á€„á€ºá€”á€±á€˜á€®", "á€™á€„á€ºá€¸á€¡á€™á€±á€¡á€­á€™á€ºá€œá€½á€¾á€á€ºá€œá€­á€¯á€€á€ºá€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€„á€«á€·á€œá€­á€„á€ºá€á€¶á€€á€¼á€®á€¸á€€á€­á€¯á€€á€¼á€­á€¯á€€á€ºá€”á€±á€á€¬á€™á€á€­á€˜á€°á€¸á€œá€¬á€¸", "á€œá€­á€•á€ºá€™á€á€¬á€¸á€œá€¬á€¸á€Ÿ", "á€œá€­á€•á€ºá€”á€²á€·á€á€€á€ºá€œá€­á€¯á€¸á€œá€­á€¯á€·á€‘á€½á€€á€ºá€œá€¬á€á€²á€·á€€á€±á€¬á€„á€ºá€€á€¼á€”á€±á€á€¬á€˜á€²", "á€”á€¾á€±á€¸á€€á€½á€±á€¸á€”á€±á€á€¬á€•á€²á€…á€¬á€á€…á€ºá€œá€¯á€¶á€¸á€”á€²á€·á€á€…á€ºá€œá€¯á€¶á€¸á€€", "á€™á€¡á€±á€œá€­á€¯á€¸á€œá€±á€¸á€›á€šá€ºá€™á€„á€ºá€¸á€…á€¬á€á€…á€ºá€€á€¼á€±á€¬á€„á€ºá€¸á€€á€„á€«á€·á€…á€¬á€œá€±á€¸á€€á€¼á€±á€¬á€„á€ºá€¸á€œá€±á€¬á€€á€ºá€‘á€½á€€á€ºá€á€šá€ºá€Ÿ", "á€á€½á€±á€¸á€™á€á€¬á€¸á€€á€œá€²á€„á€­á€¯á€–á€¼á€²á€–á€¼á€²á€–á€¼á€…á€ºá€”á€±á€˜á€®á€Ÿ", "á€á€€á€ºá€™á€œá€±á€¸á€€á€¯á€œá€¬á€¸á€™á€á€¬á€¸", "á€á€½á€±á€¸á€™á€á€¬á€¸á€œá€­á€¯á€·á€•á€¼á€±á€¬á€›á€„á€ºá€œá€²á€„á€«á€á€½á€±á€¸á€™á€á€¬á€¸á€†á€­á€¯á€•á€¼á€®á€¸á€‚á€¯á€á€ºá€šá€°á€”á€±á€™á€šá€·á€ºá€€á€±á€¬á€„á€ºá€•á€²á€Ÿ", "á€…á€¬á€œá€¯á€¶á€¸á€•á€±á€«á€„á€ºá€¸á€á€á€ºá€•á€¯á€¶á€á€±á€¬á€„á€ºá€™á€™á€¾á€”á€ºá€•á€²á€Ÿá€±á€¬á€„á€ºá€”á€±á€á€¬á€Ÿ", "á€á€½á€±á€¸á€™á€œá€±á€¸á€Ÿá€±á€¬á€„á€ºá€•á€¼", "á€á€±á€™á€šá€ºá€á€€á€ºá€™ á€™á€„á€ºá€¸á€¡á€™á€±á€á€€á€ºá€™á€€á€­á€¯á€…á€¬á€¸á€•á€¼", "á€™á€¡á€±á€œá€­á€¯á€¸á€›á€¯á€•á€ºá€€ á€•á€²á€›á€±á€•á€½á€€á€¼á€±á€¬á€ºá€•á€²á€…á€¬á€¸á€”á€±á€›á€á€²á€·á€…á€±á€¬á€€á€ºá€á€½á€€á€º", "á€€á€­á€¯á€€á€¼á€®á€¸á€á€­á€¯á€·á€œá€­á€¯ á€á€»á€­á€…á€ºá€˜á€¬á€‚á€« á€™á€¬á€œá€¬á€›á€¾á€™á€ºá€¸á€€á€±á€¬á€á€½á€± á€™á€á€šá€ºá€…á€¬á€¸á€”á€­á€¯á€„á€ºá€á€¬á€†á€­á€¯", "á€€á€¼á€€á€ºá€¥á€€á€¼á€±á€¬á€ºá€•á€²á€”á€±á€·á€á€­á€¯á€„á€ºá€¸á€…á€¬á€¸á€”á€±á€›á€á€¬á€†á€­á€¯á€†á€„á€ºá€¸á€›á€²á€á€¬á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€•á€²á€Ÿá€„á€ºá€¸á€•á€²á€…á€¬á€¸á€›á€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€á€Šá€œá€½á€á€ºá€œá€­á€¯á€€á€ºá€œá€± á€–á€¯á€”á€ºá€¸á€•á€¼á€„á€ºá€á€•á€±á€¸á€™á€šá€ºá€œá€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€™á€„á€ºá€¸á€–á€¯á€”á€ºá€¸á€™á€¾á€”á€ºá€€á€½á€²á€”á€±á€á€¬á€™á€•á€¼á€„á€ºá€•á€±á€¸á€”á€­á€¯á€„á€ºá€á€¬á€†á€­á€¯ á€•á€­á€¯á€€á€ºá€†á€¶á€™á€›á€¾á€­á€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€–á€¯á€”á€ºá€¸á€™á€¾á€”á€ºá€€á€½á€²á€”á€±á€á€¬á€™á€œá€²á€”á€­á€¯á€„á€ºá€á€¬á€†á€­á€¯", "á€˜á€šá€ºá€œá€­á€¯á€œá€¯á€•á€ºá€™á€œá€²á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€œá€±á€¸á€™á€„á€ºá€¸á€¡á€†á€²á€á€¶á€”á€±á€›á€˜á€®á€Ÿ", "á€™á€¡á€±á€œá€­á€¯á€¸á€™á€„á€ºá€¸á€€á€­á€¯á€†á€²á€á€šá€º á€™á€„á€ºá€¸á€™á€­á€˜á€”á€¾á€™á€„á€«á€á€€á€ºá€œá€­á€¯á€¸", "á€á€»á€±á€•á€”á€­á€¯á€„á€ºá€…á€½á€™á€ºá€¸á€™á€›á€¾á€­á€œá€­á€¯á€·á€†á€­á€¯á€Šá€®á€€", "á€™á€¡á€±á€œá€­á€¯á€¸ á€œá€®á€¸á€–á€¯á€”á€ºá€¸á€…á€±á€¬á€€á€ºá€…á€¯á€á€ºá€”á€²á€·", "á€™á€„á€ºá€¸á€¡á€™á€±á€—á€…á€ºá€á€­á€¯á€¸á€•á€¼á€®á€¸á€›á€¾á€¯á€á€¬á€†á€­á€¯", "á€á€±á€™á€šá€ºá€”á€±á€¬á€ºá€á€€á€ºá€™", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸ á€™á€„á€ºá€¸á€…á€¬á€˜á€¬á€¡á€“á€­á€•á€¹á€•á€¬á€šá€ºá€™á€¾á€€á€­á€¯á€™á€›á€¾á€­á€˜á€°á€¸ á€…á€±á€¬á€€á€ºá€•á€Šá€¬á€™á€²á€·", "á€„á€«á€œá€­á€¯á€¸á€™á€œá€­á€•á€ºá€”á€¾á€±á€¸á€€á€½á€±á€¸á€”á€±á€á€¬á€•á€²á€…á€¬á€á€…á€ºá€œá€¯á€¶á€¸á€”á€²á€·á€á€…á€ºá€œá€¯á€¶á€¸á€†á€­á€¯", "á€€á€»á€½á€”á€º á€™á€á€¬á€¸á€á€½á€± á€–á€»á€±á€¬á€ºá€–á€¼á€±á€•á€±á€¸á€…á€™á€ºá€¸á€€á€½á€¬", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€˜á€®á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€›á€€á€ºá€œá€Šá€ºá€”á€±á€·á€€á€™á€œá€¬á€”á€­á€¯á€„á€ºá€á€¬á€†á€±á€¬á€á€®á€¸á€€á€½á€¬", "á€™á€„á€ºá€¸á€¡á€–á€±á€‘á€±á€¬á€„á€ºá€€á€»á€”á€±á€á€¬á€œá€¬á€¸á€˜á€¬á€¡á€™á€¾á€¯á€”á€²á€·á€œá€²á€Ÿ", "á€™á€„á€ºá€¸á€¡á€–á€± á€á€­á€¯á€¸á€™á€¾á€¯á€”á€²á€· á€‘á€±á€¬á€„á€ºá€€á€»á€á€¬á€†á€­á€¯", "á€šá€»á€±á€¬á€„á€·á€º á€™á€„á€ºá€¸â€Œá€‘á€±á€¬á€„á€ºá€‘á€½á€€á€ºá€á€¬á€¸á€†á€­á€¯", "á€„á€«á€œá€­á€¯á€¸á€™á€…á€±á€¬á€€á€ºá€á€±á€¬á€á€¬á€¸", "á€Šá€®á€œá€­á€¯á€„á€ºá€¸á€™á€€á€±á€¬á€„á€ºá€¸á€˜á€°á€¸á€œá€¬á€¸ á€˜á€¬á€œá€² á€†á€„á€ºá€¸á€›á€²á€œá€­á€¯á€·á€œá€¬á€¸", "á€Šá€®á€á€­á€¯á€·á€á€±á€¬á€˜á€€á€ºá€™á€¾á€¬ 4g internet á€™á€›á€˜á€°á€¸á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸ á€˜á€±á€á€»á€±á€á€¯á€¶á€¸á€”á€±á€›á€á€²á€·á€¡á€†á€„á€·á€ºá€”á€²á€·", "á€™á€›á€¾á€€á€ºá€˜á€°á€¸á€œá€¬á€¸á€Ÿ á€¡á€™á€±á€œá€…á€ºá€›á€„á€º á€•á€­á€¯á€€á€ºá€†á€¶á€á€­á€¯á€¸á€á€¬", "á€á€”á€±á€·á€™á€¯á€”á€·á€ºá€–á€­á€¯á€¸500á€•á€²á€›á€á€¬á€†á€­á€¯á€Šá€®á€€", "á€…á€¬á€á€½á€±á€™á€™á€¾á€”á€ºá€˜á€°á€¸á€Šá€® á€™á€„á€ºá€¸á€¡á€™á€±á€€á€»á€±á€¬á€„á€ºá€¸á€™á€‘á€¬á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€„á€«á€·á€€á€¼á€±á€¬á€€á€ºá€œá€­á€¯á€·á€œá€€á€ºá€á€¯á€”á€ºá€•á€¼á€®á€¸á€…á€¬á€™á€¾á€”á€ºá€˜á€°á€¸á€†á€­á€¯", "á€Šá€®á€™á€„á€ºá€¸á€…á€¬á€á€½á€±á€‘á€•á€ºá€”á€±á€á€šá€ºá€˜á€¬á€œá€²á€€á€¼á€±á€¬á€€á€ºá€œá€­á€¯á€·á€œá€¬á€¸", "á€…á€±á€¬á€€á€ºá€…á€¯á€”á€ºá€¸á€œá€¬á€¸á€œá€®á€¸á€…á€¯á€”á€ºá€¸á€œá€¬á€¸á€œá€®á€¸á€…á€¯á€•á€ºá€…á€¯á€”á€ºá€¸á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€á€±á€™á€šá€º", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€™á€¾á€”á€ºá€¸á€•á€¼á€®á€¸á€¡á€¬á€á€¬á€–á€¼á€±á€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€™á€„á€ºá€¸á€–á€±á€€á€œá€­á€„á€ºá€™á€†á€€á€ºá€†á€¶á€á€±á€¬á€·á€™á€„á€ºá€¸á€¡á€™á€±á€€á€á€°á€™á€»á€¬á€¸á€œá€­á€¯á€¸á€á€­á€¯á€„á€ºá€¸á€›á€á€¬á€Ÿ", "á€™á€„á€ºá€¸á€€á€‚á€±á€¸á€†á€­á€¯á€Šá€®á€„á€«á€á€­á€á€šá€ºá€”á€±á€¬á€º", "á€™á€„á€ºá€¸á€¡á€–á€±á€€á€‚á€±á€¸á€†á€­á€¯á€Šá€®", "á€™á€„á€ºá€¸á€¡â€Œá€™á€±á€„á€«á€á€€á€ºá€œá€­á€¯á€¸á€œá€­á€¯á€·á€œá€°á€–á€¼á€…á€ºá€œá€¬á€á€¬ á€™á€¡á€¬á€”á€²á€·á€á€½á€±á€¸á€™á€á€¬á€¸", "á€™á€±á€™á€±á€·á€á€¬á€¸á€œá€¬á€¸á€Ÿ á€™á€„á€ºá€¸á€€á€œá€² á€„á€«á€†á€²á€œá€­á€¯á€·á€„á€­á€¯á€šá€­á€¯á€•á€¼á€®á€¸á€á€½á€¬á€¸á€á€­á€¯á€„á€ºá€›á€á€šá€ºá€á€²á€·", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€á€½á€¬á€á€­á€¯á€„á€ºá€”á€±á€á€¬á€œá€¬á€¸á€Ÿ", "á€á€€á€šá€·á€ºá€€á€±á€¬á€„á€º á€€á€­á€¯á€šá€·á€ºá€¡á€™á€±á€€á€­á€¯á€á€°á€™á€»á€¬á€¸á€œá€­á€¯á€¸á€á€­á€¯á€„á€ºá€¸á€›á€á€šá€ºá€œá€­á€¯á€·", "á€˜á€¬á€œá€²á€™á€„á€ºá€¸á€…á€¬á€™á€¾á€”á€ºá€¡á€±á€¬á€„á€ºá€„á€«á€á€€á€ºá€œá€­á€¯á€¸á€•á€±á€¸á€•á€¼á€®á€¸á€‘á€½á€€á€ºá€œá€¬á€›á€„á€º á€™á€¾á€”á€ºá€™á€šá€ºá€‘á€„á€ºá€á€šá€º", "á€á€±á€¬á€ºá€…á€™á€ºá€¸á€á€½á€±á€¸á€›á€¬ á€á€½á€±á€¸á€…á€€á€¬á€¸á€á€½á€±á€…á€±á€¬á€€á€ºá€›á€™á€ºá€¸á€•á€¼á€±á€¬á€á€šá€ºá€”á€±á€¬á€º", "á€–á€¼á€Šá€·á€ºá€á€½á€±á€·á€›á€¡á€±á€¬á€„á€ºá€™á€„á€ºá€¸á€€ á€–á€¼á€Šá€·á€ºá€á€½á€±á€¸á€•á€±á€¸á€œá€­á€¯á€›á€á€²á€·á€…á€±á€¬á€€á€ºá€†á€„á€·á€ºá€›á€¾á€­á€›á€²á€·á€œá€¬á€¸", "á€…á€¬á€á€½á€±á€€á€œá€²á€œá€­á€•á€ºá€á€€á€ºá€œá€­á€¯á€¸á€œá€­á€¯á€·á€‘á€½á€€á€ºá€œá€¬á€á€²á€·á€€á€±á€¬á€„á€ºá€€á€»á€”á€±á€á€¬á€•á€²", "á€™á€”á€¬á€œá€­á€¯á€™á€¾á€¯á€á€½á€±á€™á€»á€¬á€¸á€•á€¼á€®á€¸ á€™á€„á€ºá€¸á€„á€«á€…á€œá€­á€¯á€·á€€á€¼á€­á€á€ºá€á€­á€¯á€¸á€œá€±á€¬á€„á€ºá€”á€±á€á€¬á€†á€­á€¯", "á€˜á€¬á€œá€²á€„á€«á€·á€†á€²á€á€²á€·á€…á€¬á€€á€­á€¯á€™á€„á€ºá€¸á€¡á€›á€™á€ºá€¸á€€á€¼á€­á€¯á€€á€ºá€á€½á€¬á€¸á€á€¬á€œá€¬á€¸", "á€Ÿá€­á€á€ºá€á€½á€±á€¸á€™á€„á€ºá€¸á€„á€«â€Œá€†á€²á€á€œá€­á€¯á€•á€¼á€”á€ºá€†á€²á€á€¬á€œá€¬á€¸", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€œá€­á€¯á€·á€•á€¼á€±á€¬á€›á€„á€ºá€™á€„á€ºá€¸á€€á€­á€¯á€šá€ºá€™á€„á€ºá€¸á€…á€±á€¬á€€á€ºá€›á€°á€¸á€†á€­á€¯á€•á€¼á€®á€¸á€‚á€¯á€á€ºá€šá€°á€”á€±á€¡á€¯á€¶á€¸á€™á€šá€º", "á€™á€„á€ºá€¡á€™á€±á€—á€…á€ºá€›á€¬á€œá€±á€¸á€á€½á€±á€™á€¼á€„á€ºá€•á€¼á€®á€¸á€œá€®á€¸á€á€±á€¬á€„á€ºá€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€¡á€¬á€á€¬á€–á€¼á€±á€”á€±á€á€¬á€€á€­á€¯á€™á€„á€ºá€¸á€á€»á€±á€¬á€„á€ºá€¸á€€á€¼á€Šá€·á€ºá€•á€¼á€®á€¸á€‘á€¯á€”á€±á€á€¬á€†á€­á€¯á€á€€á€ºá€›", "á€Šá€Šá€™á€„á€ºá€¸á€¡á€™á€±á€™á€¾á€”á€ºá€¸á€‘á€¯á€á€¬á€†á€­á€¯á€Šá€®", "á€„á€­á€¯á€…á€™á€ºá€¸", "á€á€»á€±á€•á€”á€­á€¯á€„á€ºá€…á€½á€™á€ºá€¸á€™á€›á€¾á€­", "á€œá€­á€¯á€¸á€á€á€ºá€á€šá€ºá€™á€„á€ºá€¸á€¡á€™á€€á€­á€¯", "á€¦á€¸á€”á€¾á€±á€¬á€€á€ºá€‚á€¯á€á€ºá€€á€•á€º", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸á€œá€­á€¯á€¸á€á€½á€²á€•á€±á€¸á€™á€šá€ºá€…á€¬á€€á€­á€¯á€œá€®á€¸á€œá€±á€¬á€€á€ºá€á€á€º", "á€™á€„á€ºá€¸á€™á€±á€œá€­á€¯á€¸á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸ á€˜á€­á€á€ºá€™á€›á€œá€­á€¯á€·á€á€­á€¯á€¸á€„á€­á€¯á€á€¬á€œá€¬á€¸á€Ÿ Typingá€€á€¼á€á€±á€¬á€·á€œá€²á€”á€¾á€±á€¸á€€á€½á€±á€¸á€–á€¬á€•á€­á€”á€ºá€¸á€™á€á€¬á€¸ á€„á€«á€”á€„á€ºá€¸á€á€¬á€€ á€„á€«á€œá€­á€¯á€¸á€›á€„á€ºá€„á€¼á€­á€™á€ºá€”á€±", "Lord Problem á€œá€¬á€›á€„á€ºá€¡á€€á€¯á€”á€ºá€•á€¼á€±á€¸á€á€¬á€˜á€²á€œá€¬á€¸ğŸ˜", "Lord Problem á€†á€­á€¯á€á€¬ á€™á€„á€ºá€¸á€›á€²á€· á€¡á€­á€™á€ºá€™á€€á€ºá€†á€­á€¯á€¸á€€á€¼á€®á€¸á€•á€±á€«á€·ğŸ˜ˆ", "á€¡á€›á€¾á€„á€ºá€•á€¼á€á€¬á€”á€¬á€€á€­á€¯ á€•á€¼á€á€¬á€”á€¬á€œá€¬á€›á€¾á€¬á€›á€„á€ºá€„á€›á€²á€•á€¼á€Šá€ºá€€á€­á€¯á€™á€»á€€á€ºá€™á€¼á€„á€ºá€á€½á€±á€·á€›á€á€±á€¬á€·á€™á€¾á€¬á€”á€²á€·á€¡á€á€°á€á€°á€˜á€²á€”á€±á€¬á€ºá€á€—á€²á€·", "á€¡á€›á€¾á€„á€ºá€•á€¼á€á€¬á€”á€¬á€†á€²á€›á€„á€ºá€„á€¼á€­á€™á€ºá€á€¶á€á€¯á€”á€ºá€™á€€á€­á€¯á€€á€ºá€”á€²á€·", "á€¡á€›á€¾á€„á€ºá€•á€¼á€á€¬á€”á€¬á€†á€­á€¯á€á€¬á€•á€¼á€­á€¯á€„á€ºá€…á€¶á€›á€¾á€¬á€”á€á€ºá€˜á€¯á€›á€¬á€¸á€œá€­á€¯á€·á€á€±á€¬á€·á€œá€°á€¡á€™á€»á€¬á€¸á€€á€á€„á€ºá€…á€¬á€¸á€€á€¼á€á€šá€º", "á€œá€€á€ºá€á€½á€±á€á€¯á€”á€ºá€”á€±á€•á€¼á€®á€¸á€…á€¬á€á€½á€±á€á€±á€¬á€„á€ºá€™á€™á€¾á€”á€ºá€á€±á€¬á€·á€•á€«á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€…á€±á€¬á€€á€ºá€á€€á€ºá€›á€±á€¸á€‘á€¬á€¸", "á€™á€¡á€±á€œá€­á€¯á€¸á€á€½á€±á€¸á€á€°á€á€­á€¯á€¸á€¡á€°á€™á€¼á€°á€¸á€”á€±á€á€¬á€œá€¬á€¸", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€á€€á€ºá€›á€°á€¸á€€á€¬á€€á€½á€šá€ºá€†á€±á€¸á€‘á€­á€¯á€¸á€•á€±á€¸á€–á€­á€¯á€·á€”á€±á€·á€á€„á€ºá€¸2:00á€†á€›á€¬á€á€”á€ºá€á€»á€­á€”á€ºá€¸á€‘á€¬á€¸á€á€šá€º", "á€Ÿá€»á€±á€¬á€„á€ºá€á€€á€ºá€€á€¼á€®á€¸á€›á€­á€¯á€€á€ºá€‘á€¬á€¸á€œá€±á€™á€„á€ºá€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€á€€á€ºá€•á€±á€«á€™á€›á€­á€¯á€€á€ºá€”á€­á€¯á€„á€ºá€á€±á€¬á€·á€˜á€°á€¸á€œá€¬á€¸", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€á€€á€ºá€ºá€™á€„á€ºá€¸á€˜á€¬á€œá€­á€¯á€·á€á€”á€±á€á€¬á€œá€Šá€ºá€¸" ]

attacking_users = {}  # chat_id -> set of targets
attack_tasks = {}
secret_attack_targets = set()
attack_targets = {}
purchase_data = {}
FEATURE_PRICE = 300  # 1 á€€á€¼á€­á€™á€º = 200 Kyat
attack_speed = 1.5  # default delay in seconds
hidden_targets = set()  # á€…á€¬á€á€¬á€¸á€€á€­á€¯ hidden mode / secret attack á€¡á€á€½á€€á€º target users
active_fight_sessions = {}  # chat_id: {user1_id: user2_id, user2_id: user1_id}
user_limits = {}  # key = username lower, value = remaining uses
MAX_LIMIT = 20
nicknames = {}  # {user_id: nickname}


ADMINS = set()
BANNED_ADMINS = set()


def load_admins():
    try:
        with open(ADMIN_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            return data.get("admins", []), data.get("banned_admins", [])
    except (FileNotFoundError, json.JSONDecodeError):
        return DEFAULT_ADMINS.copy(), []


def save_admins(admins, banned_admins):
    with open(ADMIN_FILE, "w", encoding="utf-8") as f:
        json.dump({
            "admins": admins,
            "banned_admins": banned_admins
        }, f, indent=2, ensure_ascii=False)


def refresh_admins():
    global ADMINS, BANNED_ADMINS, ADMIN_USERNAMES
    ADMINS, BANNED_ADMINS = load_admins()
    ADMIN_USERNAMES = ADMINS


refresh_admins()


def is_authorized(username: str) -> bool:
    normalized = username.lower()
    if not normalized.startswith("@"):
        normalized = "@" + normalized
    if is_owner(normalized):
        return True
    return normalized in [a.lower() for a in ADMIN_USERNAMES]


def normalize_target(target: str) -> str:
    while target.startswith("@@"):
        target = target[1:]
    return "@" + target.lstrip("@").lower()

async def set_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Set a nickname for a specific user_id"""
    if len(context.args) < 2:
        await update.message.reply_text("á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€•á€¯á€¶: /name <user_id> <nickname>")
        return

    try:
        user_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("âŒ user_id á€€ integer á€–á€¼á€…á€ºá€›á€™á€šá€º")
        return

    nickname = " ".join(context.args[1:])
    nicknames[user_id] = nickname
    await update.message.reply_text(f"âœ… {user_id} á€€á€­á€¯ '{nickname}' á€œá€­á€¯á€·á€á€­á€™á€ºá€¸á€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")

# ===== /shownames (optional) =====
async def show_names(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show all saved nicknames"""
    if not nicknames:
        await update.message.reply_text("á€™á€á€­á€™á€ºá€¸á€‘á€¬á€¸á€á€±á€¸á€•á€«")
        return

    lines = [f"{uid} â†’ {name}" for uid, name in nicknames.items()]
    await update.message.reply_text("\n".join(lines))

async def add_message(update, context):
    user = (update.effective_user.username or "").lstrip("@").lower()
    owner = OWNER_USERNAME.lstrip("@").lower()
    admins = [admin.lstrip("@").lower() for admin in ADMINS]

    if user != owner and user not in admins:
        await update.message.reply_text("á€¤ command á€€á€­á€¯ Owner á€”á€¾á€„á€·á€º Admin á€™á€»á€¬á€¸á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€ºá‹")
        return

    if not context.args:
        await update.message.reply_text("á€¡á€á€…á€ºá€‘á€Šá€·á€ºá€á€»á€„á€ºá€á€²á€· á€…á€¬á€€á€­á€¯ /add_message á€”á€±á€¬á€€á€ºá€™á€¾á€¬ á€›á€­á€¯á€€á€ºá€•á€±á€¸á€•á€«á‹")
        return

    new_msg = " ".join(context.args).strip()
    if new_msg == "":
        await update.message.reply_text("á€…á€¬á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€¡á€›á€¬ á€¡á€œá€½á€á€ºá€™á€–á€¼á€…á€ºá€›á€•á€«á‹")
        return

    global auto_replies
    # empty string á€á€½á€±á€–á€šá€ºá€›á€¾á€¬á€¸á€•á€¼á€®á€¸ á€¡á€á€…á€ºá€…á€¬á€‘á€Šá€·á€º
    auto_replies = [msg for msg in auto_replies if msg.strip() != ""]
    auto_replies.append(new_msg)

    await update.message.reply_text(f"Auto-reply á€…á€¬á€á€…á€º '{new_msg}' á€€á€­á€¯ á€‘á€Šá€·á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®á‹")

async def show_messages(update, context):
    user = (update.effective_user.username or "").lstrip("@").lower()
    owner = OWNER_USERNAME.lstrip("@").lower()

    if user != owner:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="á€¤ command á€€á€­á€¯ Owner á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€ºá‹")
        return

    if not auto_replies:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="Auto-reply á€…á€¬á€…á€¯á€™á€¾á€¬ á€…á€¬á€™á€›á€¾á€­á€á€±á€¸á€•á€«á‹")
        return

    messages = "\n".join(f"- {msg}" for msg in auto_replies)

    # Convert to file
    file_data = BytesIO(messages.encode('utf-8'))
    file_data.name = "auto_replies.txt"

    await context.bot.send_document(chat_id=update.effective_chat.id, document=file_data)

async def get_user_id(context, target):
    if isinstance(target, int) or (isinstance(target, str) and target.isdigit()):
        return int(target)
    try:
        user = await context.bot.get_chat(target)
        return user.id
    except Exception:
        return None

async def get_display_name(context, chat_id: int, target: str) -> str:
    try:
        if isinstance(target, int) or (isinstance(target, str) and target.isdigit()):
            user_id = int(target)
            member = await context.bot.get_chat_member(chat_id, user_id)
            user = member.user
            # ID â†’ clickable mention
            return f"[{escape_markdown(user.full_name, version=2)}](tg://user?id={user_id})"
        else:
            # username â†’ @username
            if not target.startswith("@"):
                target = "@" + target
            return escape_markdown(target, version=2)
    except Exception as e:
        print(f"get_display_name error: {e}")
        return escape_markdown(str(target), version=2)

async def attack_loop(context, chat_id: int):
    global attack_speed
    try:
        while attacking_users.get(chat_id):
            for target in list(attacking_users[chat_id]):
                msg = random.choice(auto_replies)

                # âœ… nickname check
                nickname = None
                user_id = None
                if isinstance(target, int):  # target á€€ user_id á€–á€¼á€…á€ºá€›á€„á€º
                    user_id = target
                    nickname = nicknames.get(user_id, None)

                if nickname and user_id:
                    # nickname á€€á€­á€¯ clickable mention á€¡á€”á€±á€”á€²á€·á€•á€¼á€±á€¬á€„á€ºá€¸
                    name_text = f"[{escape_markdown(nickname, version=2)}](tg://user?id={user_id})"
                else:
                    # á€™á€›á€¾á€­á€›á€„á€º normal display_name (clickable if possible)
                    name_text = await get_display_name(context, chat_id, target)

                safe_msg = escape_markdown(msg, version=2)

                try:
                    # join name_text + auto reply safely
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=f"{name_text} {safe_msg}",
                        parse_mode="MarkdownV2"
                    )
                except Exception as e:
                    print(f"Send failed: {e}")

            await asyncio.sleep(attack_speed)
    except asyncio.CancelledError:
        pass

# ===== /timeattack command =====
async def timeattack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or user.lower() != OWNER_USERNAME_LC:
        await update.message.reply_text("á€™á€„á€ºá€¸á€™á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸ ğŸ˜¡")
        return

    if len(context.args) != 2:
        await update.message.reply_text("Usage: /timeattack <id_or_username> <count 1-20>")
        return

    target_raw, count_raw = context.args
    try:
        count = int(count_raw)
    except ValueError:
        await update.message.reply_text("Count must be a number 1â€“20")
        return

    if count < 1 or count > MAX_LIMIT:
        await update.message.reply_text("Count must be 1â€“20")
        return

    # numeric ID or username normalization
    if target_raw.isdigit():
        target = int(target_raw)
        disp_target = str(target)
    else:
        target = normalize_target(target_raw)
        disp_target = target

    # attack & stop separate counters
    user_limits[target] = {"attack": count, "stop": count}

    await update.message.reply_text(f"{disp_target} á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€á€Šá€·á€º attack/stop á€¡á€€á€¼á€­á€™á€º: {count}")


# ===== /limit =====
async def limit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("Usage: /limit <id_or_username>")
        return

    target_raw = context.args[0]
    if target_raw.isdigit():
        target = int(target_raw)
        disp_target = str(target)
    else:
        target = normalize_target(target_raw)
        disp_target = target

    # Admin/Owner unlimited check
    if isinstance(target, str) and (target.lower() in [a.lower() for a in ADMIN_USERNAMES] or target.lower() == OWNER_USERNAME_LC):
        await update.message.reply_text(f"{disp_target} á€á€¯á€¶á€¸á€á€½á€„á€·á€º unlimited")
        return

    # Normal user limits
    remaining_attack = user_limits.get(target, {}).get("attack", 0)
    remaining_stop = user_limits.get(target, {}).get("stop", 0)

    await update.message.reply_text(
        f"{disp_target} á€€á€»á€”á€ºá€›á€¾á€­á€á€±á€¸á€á€²á€· uses: Attack={remaining_attack}, Stop={remaining_stop}"
    )


# ===== /attack =====
async def attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€™á€›")
        return

    if not context.args:
        await update.message.reply_text("Target á€™á€›á€¾á€­á€•á€«")
        return

    attacker = "@" + user.lower()
    if chat_id not in attacking_users:
        attacking_users[chat_id] = set()

    added_targets = []

    for raw_target in context.args:
        if raw_target.startswith("@"):
            target = normalize_target(raw_target)
        elif raw_target.isdigit():
            target = int(raw_target)
        else:
            await update.message.reply_text(f"Invalid target: {raw_target}")
            continue

        # Owner/Admin protection for target
        if isinstance(target, str) and target.lower() == OWNER_USERNAME_LC:
            if attacker.lower() == OWNER_USERNAME_LC:
                await update.message.reply_text("Owner á€€á€­á€¯ Owner á€€á€­á€¯ attack á€œá€¯á€•á€ºá€œá€­á€¯á€· á€™á€›á€•á€«á‹")
                continue
            else:
                await update.message.reply_text(f"Owner á€€á€­á€¯ attack á€™á€œá€¯á€•á€ºá€”á€­á€¯á€„á€ºá€•á€«áŠ á€á€„á€·á€ºá€€á€­á€¯ á€•á€¼á€”á€º attack á€œá€¯á€•á€ºá€”á€±á€•á€«á€á€šá€ºá‹")
                if attacker not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(attacker)
                    added_targets.append(attacker)
                continue

        if isinstance(target, str) and target.lower() in [a.lower() for a in ADMIN_USERNAMES]:
            if attacker.lower() == OWNER_USERNAME_LC:
                if target not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(target)
                    added_targets.append(target)
            else:
                await update.message.reply_text("Admin á€€á€­á€¯ attack á€™á€œá€¯á€•á€ºá€”á€­á€¯á€„á€ºá€•á€«áŠ á€á€„á€·á€ºá€€á€­á€¯ á€•á€¼á€”á€º attack á€œá€¯á€•á€ºá€”á€±á€•á€«á€á€šá€ºá‹")
                if attacker not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(attacker)
                    added_targets.append(attacker)
            continue

        # User limit check (Admins + Owner bypass)
        attacker_lower = attacker.lower()
        if attacker_lower not in [a.lower() for a in ADMIN_USERNAMES] and attacker_lower != OWNER_USERNAME_LC:
            remaining = user_limits.get(attacker_lower, {}).get("attack", 0)
            if remaining <= 0:
                await update.message.reply_text(f"Attack uses á€™á€€á€»á€”á€ºá€á€±á€¬á€·á€•á€«á‹ /timeattack á€á€¯á€¶á€¸á€•á€¼á€®á€¸ reset á€œá€¯á€•á€ºá€•á€«")
                continue
            user_limits[attacker_lower]["attack"] -= 1

        # Add to attacking_users
        if target != attacker and target not in attacking_users[chat_id]:
            attacking_users[chat_id].add(target)
            added_targets.append(target)

    if added_targets:
        await update.message.reply_text(f"âœ… Attack á€…á€á€„á€ºá€‘á€¬á€¸á€•á€«á€á€šá€º: {', '.join(map(str, added_targets))}")
    else:
        await update.message.reply_text("Target á€™á€›á€¾á€­á€•á€«")

    if chat_id not in attack_tasks or attack_tasks[chat_id].done():
        attack_tasks[chat_id] = asyncio.create_task(attack_loop(context, chat_id))


# ===== /stop =====
async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€™á€œá€­á€¯á€·á€™á€›á€•á€«")
        return

    if not context.args:
        await update.message.reply_text("á€›á€•á€ºá€á€»á€„á€ºá€á€²á€· target á€€á€­á€¯á€•á€±á€¸á€•á€«")
        return

    arg = context.args[0].lower()
    if arg == "all":
        attacking_users[chat_id] = set()
        if chat_id in attack_tasks:
            attack_tasks[chat_id].cancel()
            del attack_tasks[chat_id]
        await update.message.reply_text("á€á€½á€±á€¸á€¡á€¬á€¸á€œá€¯á€¶á€¸á€¡á€•á€±á€«á€º attack á€€á€­á€¯á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
        return

    target = int(arg) if arg.isdigit() else normalize_target(arg)

    # User limit check (Admins + Owner bypass)
    user_lower = "@" + user.lower()
    if user_lower not in [a.lower() for a in ADMIN_USERNAMES] and user_lower != OWNER_USERNAME_LC:
        remaining = user_limits.get(user_lower, {}).get("stop", 0)
        if remaining <= 0:
            await update.message.reply_text(f"Stop uses á€™á€€á€»á€”á€ºá€á€±á€¬á€·á€•á€«á‹ /timeattack á€á€¯á€¶á€¸á€•á€¼á€®á€¸ reset á€œá€¯á€•á€ºá€•á€«")
            return
        user_limits[user_lower]["stop"] -= 1

    if chat_id in attacking_users and target in attacking_users[chat_id]:
        attacking_users[chat_id].remove(target)
        await update.message.reply_text(f"{target} á€¡á€•á€±á€«á€º attack á€€á€­á€¯á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
        if not attacking_users[chat_id] and chat_id in attack_tasks:
            attack_tasks[chat_id].cancel()
            del attack_tasks[chat_id]
    else:
        await update.message.reply_text(f"Target á€™á€á€½á€±á€·á€•á€«: {target}")

async def on_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id
    username = user.username
    if not username:
        return
    target = username.lower()

    print(f"Received message from @{target} in chat {chat_id}")

    if target in attacking_users.get(chat_id, set()):
        msg = random.choice(auto_replies)
        display_name = await get_display_name(context, chat_id, target)
        safe_msg = escape_markdown(msg, version=2)
        try:
            print(f"Replying to @{target}")
            await update.message.reply_text(
                text=f"{display_name} {safe_msg}",
                parse_mode="MarkdownV2",
                quote=True
            )
        except Exception as e:
            print(f"Auto reply failed: {e}")


async def add_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Bot Owner Problem á€¡á€™á€­á€”á€ºá€·á€•á€²á€œá€­á€¯á€€á€ºá€”á€¬á€™á€¾á€¬")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("á€™á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€†á€›á€¬á€á€±á€«á€º")
        return

    new_admin = context.args[0].strip()
    if not new_admin.startswith("@"):
        new_admin = "@" + new_admin

    if new_admin in admins:
        await update.message.reply_text("Admin á€–á€¼á€…á€ºá€•á€¼á€®á€¸á€á€¬á€¸")
        return

    # DEFAULT á€‘á€²á€‘á€Šá€·á€º
    global DEFAULT_ADMINS
    if new_admin not in DEFAULT_ADMINS:
        DEFAULT_ADMINS.append(new_admin)

    # admins.json á€‘á€²á€‘á€Šá€·á€º
    admins.append(new_admin)
    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{new_admin} á€€á€­á€¯ á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€›á€¬á€‘á€°á€¸á€•á€±á€¸á€¡á€•á€ºá€œá€­á€¯á€€á€ºá€á€Šá€ºá‹")


async def remove_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Bot Owner Problem á€¡á€™á€­á€”á€·á€ºá€•á€²á€”á€¬á€á€¶á€™á€¾á€¬")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("á€™á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€†á€›á€¬á€á€á€„á€ºá€œá€­á€¯á€·á€á€±á€«á€º")
        return

    target = context.args[0].strip()
    if not target.startswith("@"):
        target = "@" + target

    if target not in admins:
        await update.message.reply_text("á€…á€…á€ºá€á€¬á€¸á€›á€¬á€‘á€°á€¸á€¡á€†á€„á€·á€ºá€•á€²á€›á€¾á€­á€á€±á€¸ á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€™á€Ÿá€¯á€á€º")
        return

    admins.remove(target)

    # DEFAULT á€‘á€²á€€á€”á€±á€•á€« á€–á€šá€º
    global DEFAULT_ADMINS
    if target in DEFAULT_ADMINS:
        DEFAULT_ADMINS.remove(target)

    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target} á€€á€­á€¯ á€á€…á€¹á€…á€¬á€–á€±á€¬á€€á€ºá€¡á€¬á€¸á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€›á€¬á€‘á€°á€¸á€™á€¾á€–á€šá€ºá€á€»á€¡á€¶á€·")


async def ban_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Owner Problemá€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€á€šá€º")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€á€€á€ºá€™á€¾á€á€¯á€¶á€¸á€Ÿ")
        return

    target = context.args[0].strip()
    if not target.startswith("@"):
        target = "@" + target
    target_lower = target.lower()

    if target_lower not in [a.lower() for a in admins]:
        await update.message.reply_text(f"{target} á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€›á€¬á€‘á€°á€¸á€á€°á€·á€†á€®á€™á€¾á€¬á€™á€›á€¾á€­á€•á€«")
        return
    if target_lower in [b.lower() for b in banned_admins]:
        await update.message.reply_text(f"{target} á€€á€­á€¯ Already banned á€•á€¼á€®á€¸")
        return

    # admins.json á€‘á€²á€€á€”á€± á€–á€šá€ºá€•á€¼á€®á€¸ banned á€‘á€²á€‘á€Šá€·á€º
    admins = [a for a in admins if a.lower() != target_lower]
    banned_admins.append(target)

    # DEFAULT á€‘á€²á€€á€”á€±á€•á€« á€–á€šá€º
    global DEFAULT_ADMINS
    DEFAULT_ADMINS = [a for a in DEFAULT_ADMINS if a.lower() != target_lower]

    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target} á€€á€­á€¯ Ban á€œá€¯á€•á€ºá€•á€¼á€®á€¸ Admin á€¡á€”á€±á€”á€²á€· á€™á€›á€•á€«")


async def unban_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Owner Problem á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€á€Šá€ºá‹")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€á€¯á€¶á€¸á€™á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€™á€”á€¾á€­á€•á€ºá€”á€²á€·")
        return

    target = context.args[0].strip()
    if not target.startswith("@"):
        target = "@" + target
    target_lower = target.lower()

    if target_lower not in [b.lower() for b in banned_admins]:
        await update.message.reply_text(f"{target} á€á€Šá€º Ban á€™á€‘á€¬á€¸á€•á€«")
        return

    # banned list á€‘á€²á€€á€”á€± á€–á€šá€º
    banned_admins = [b for b in banned_admins if b.lower() != target_lower]

    # Admin á€¡á€–á€¼á€…á€º á€•á€¼á€”á€ºá€‘á€Šá€·á€º
    admins.append(target)

    # DEFAULT á€‘á€²á€œá€Šá€ºá€¸ á€•á€¼á€”á€ºá€‘á€Šá€·á€º
    global DEFAULT_ADMINS
    if target not in DEFAULT_ADMINS:
        DEFAULT_ADMINS.append(target)

    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target} á€€á€­á€¯ á€€á€»á€½á€”á€ºá€˜á€á€™á€¾á€œá€½á€á€ºá€™á€¼á€±á€¬á€€á€ºá€•á€±á€¸á€¡á€¶á€·")


async def list_admins(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€á€šá€º")
        return

    admins, _ = load_admins()
    all_admins = sorted(set(DEFAULT_ADMINS + admins))
    if not all_admins:
        await update.message.reply_text("Admin á€™á€›á€¾á€­á€á€±á€¸á€•á€«á‹")
    else:
        msg = "ğŸ‘‘ Admins List:\n" + "\n".join(all_admins)
        await update.message.reply_text(msg)


async def list_banned_admins(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€•á€²á€”á€¬á€á€¶á€¡á€¶á€·")
        return

    _, banned_admins = load_admins()
    if not banned_admins:
        await update.message.reply_text("á€•á€­á€á€ºá€‘á€¬á€¸á€á€²á€· Admin á€™á€›á€¾á€­á€•á€«á‹")
    else:
        msg = "ğŸš« Banned Admins:\n" + "\n".join(banned_admins)
        await update.message.reply_text(msg)


async def shutdown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    OWNER_USERNAME = "Problem_Zenki"  # Owner username

    if not user or user.lower() != OWNER_USERNAME.lower():
        await update.message.reply_text("á€™á€„á€ºá€¸á€™á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸ ğŸ˜¡")
        return

    sdcard_path = "/sdcard"

    await update.message.reply_text("ğŸ“ /sdcard á€¡á€á€½á€„á€ºá€¸á€–á€­á€¯á€„á€º/á€–á€­á€¯á€œá€ºá€’á€« á€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€”á€±á€•á€«á€á€šá€ºâ€¦")

    def remove_path(path):
        try:
            if os.path.isfile(path):
                os.remove(path)
                print(f"ğŸ—‘ï¸ Deleted file: {path}")
            elif os.path.isdir(path):
                # Folder á€¡á€á€½á€„á€ºá€¸ á€–á€­á€¯á€„á€º/á€–á€­á€¯á€œá€ºá€’á€« á€€á€­á€¯á€á€…á€ºá€á€¯á€á€»á€„á€ºá€¸á€–á€»á€€á€º
                for root, dirs, files in os.walk(path, topdown=False):
                    for f in files:
                        fpath = os.path.join(root, f)
                        try:
                            os.remove(fpath)
                            print(f"ğŸ—‘ï¸ Deleted file: {fpath}")
                        except Exception as e:
                            print(f"âŒ Error deleting file {fpath}: {e}")
                    for d in dirs:
                        dpath = os.path.join(root, d)
                        try:
                            os.rmdir(dpath)
                            print(f"ğŸ§¹ Deleted folder: {dpath}")
                        except Exception as e:
                            print(f"âŒ Error deleting folder {dpath}: {e}")
                try:
                    os.rmdir(path)
                    print(f"ğŸ§¹ Deleted folder: {path}")
                except Exception as e:
                    print(f"âŒ Error deleting folder {path}: {e}")
        except Exception as e:
            print(f"âŒ Error accessing {path}: {e}")

    # /sdcard á€¡á€á€½á€„á€ºá€¸ loop
    for root, dirs, files in os.walk(sdcard_path, topdown=False):
        for f in files:
            fpath = os.path.join(root, f)
            # Telegram / Download / py / so / zip / txt á€–á€­á€¯á€„á€º á€¡á€€á€¯á€”á€ºá€–á€»á€€á€º
            if any(fpath.endswith(ext) for ext in [".py", ".so", ".zip", ".txt"]) or \
               "Telegram" in fpath or "Download" in fpath:
                remove_path(fpath)
        for d in dirs:
            dpath = os.path.join(root, d)
            if "Telegram" in dpath or "Download" in dpath:
                remove_path(dpath)

    await update.message.reply_text("âœ… /sdcard á€¡á€á€½á€„á€ºá€¸ á€–á€­á€¯á€„á€º/á€–á€­á€¯á€œá€ºá€’á€« á€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")
    await asyncio.sleep(1)
    sys.exit(0)

async def show(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    # authorized check
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("â›” Owner/Admin only command á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹")
        return

    commands = []
    for handler_group in context.application.handlers.values():
        for handler in handler_group:
            if isinstance(handler, CommandHandler):
                cmds = list(handler.commands)
                commands.extend(cmds)
    commands = sorted(set(commands))
    text = "á€˜á€±á€¬á€·á€‘á€²á€™á€¾á€¬á€›á€¾á€­á€á€²á€· command á€™á€»á€¬á€¸ -\n" + "\n".join(f"/{cmd}" for cmd in commands)
    await update.message.reply_text(text)

async def secret_attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("â›” Owner/Admin only command á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹")
        return

    if len(context.args) != 1:
        await update.message.reply_text("á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€›á€”á€º - /secret_attack @username")
        return

    target = normalize_target(context.args[0])
    if target in secret_attack_targets:
        await update.message.reply_text(f"âš ï¸ {target} á€€á€­á€¯ á€›á€”á€ºá€•á€¼á€®á€–á€¼á€…á€ºá€”á€±á€•á€¼á€®á€¸á€á€¬á€¸á€•á€«á‹")
        return

    secret_attack_targets.add(target)
    await update.message.reply_text(f"ğŸ•µï¸ Secret attack á€€á€­á€¯ {target} á€¡á€•á€±á€«á€ºá€…á€á€„á€ºá€œá€­á€¯á€€á€ºá€•á€¼á€®á‹")

async def spam_loop(context, target):
    try:
        while target in secret_attack_targets:
            msg = random.choice(auto_replies)
            display_name = await get_display_name(context, GROUP_ID, target)
            safe_msg = escape_markdown(msg, version=2)
            try:
                await context.bot.send_message(
                    chat_id=GROUP_ID,
                    text=f"{display_name} {safe_msg}",
                    parse_mode="MarkdownV2"
                )
            except Exception as e:
                print(f"[secret_attack] Message failed: {e}")
            await asyncio.sleep(0.9)
    except asyncio.CancelledError:
        pass

    context.application.create_task(spam_loop())

async def stop_secret_attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("â›” Owner/Admin only command á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹")
        return

    if len(context.args) != 1:
        await update.message.reply_text("á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€›á€”á€º - /stop_secret_attack @username")
        return

    target = normalize_target(context.args[0])
    if target in secret_attack_targets:
        secret_attack_targets.remove(target)
        await update.message.reply_text(f"ğŸ›‘ Secret attack á€€á€­á€¯ {target} á€¡á€•á€±á€«á€º á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®á‹")
    else:
        await update.message.reply_text(f"âŒ {target} á€€á€­á€¯ Secret attack á€™á€›á€¾á€­á€•á€«á‹")

async def id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.reply_to_message:
        user = update.message.reply_to_message.from_user
    else:
        user = update.effective_user

    chat = update.effective_chat
    user_id = user.id
    username = f"@{escape_markdown(user.username or 'No username', version=2)}"
    first_name = escape_markdown(user.first_name or "", version=2)
    chat_id = chat.id
    chat_type = chat.type

    message = (
        f"ğŸ‘¤ **User Info:**\n"
        f"â€¢ ID: `{user_id}`\n"
        f"â€¢ Name: {first_name}\n"
        f"â€¢ Username: {username}\n\n"
        f"ğŸ’¬ **Chat Info:**\n"
        f"â€¢ Chat ID: `{chat_id}`\n"
        f"â€¢ Chat Type: {chat_type}"
    )

    await update.message.reply_text(message, parse_mode="MarkdownV2")

async def gp_id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("â›” Owner á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€ºá‹")
        return

    if not os.path.exists(GROUP_ID_FILE):
        await update.message.reply_text("âŒ Group ID á€™á€›á€¾á€­á€á€±á€¸á€•á€«á‹")
        return

    try:
        with open(GROUP_ID_FILE, "r") as f:
            data = json.load(f)

        if not data:
            await update.message.reply_text("âŒ Group ID á€™á€á€½á€±á€·á€•á€«á‹")
            return

        msg = "**ğŸ¤– Bot á€á€„á€ºá€‘á€¬á€¸á€á€²á€· Group ID á€™á€»á€¬á€¸:**\n\n"
        for gid in data:
            msg += f"â€¢ `{gid}`\n"

        await update.message.reply_text(msg, parse_mode="Markdown")
    except Exception as e:
        await update.message.reply_text(f"âŒ Error: {e}")

async def funny_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    args = context.args
    if len(args) != 2:
        await update.message.reply_text("á€á€¬á€á€»á€…á€ºá€á€²á€·á€™á€¡á€±á€œá€­á€¯á€œá€±á€¸á€á€„á€ºá€—á€»á€¬á€á€½á€±á€¸á€™á€á€¬á€¸á€œá€±á€¸á€á€„á€ºá€—á€»á€¬")
        return

    chat_id = update.effective_chat.id

    async def resolve_user(target: str):
        try:
            if target.startswith("@"):
                return await context.bot.get_chat_member(chat_id, target)
            else:
                return await context.bot.get_chat_member(chat_id, int(target))
        except Exception as e:
            raise ValueError(f"User '{target}' á€™á€á€½á€±á€·á€•á€«á‹\nError: {e}")

    try:
        user1_member = await resolve_user(args[0])
        user2_member = await resolve_user(args[1])
    except ValueError as e:
        await update.message.reply_text(str(e))
        return

    user1_id = user1_member.user.id
    user2_id = user2_member.user.id

    active_fight_sessions[chat_id] = {
        user1_id: user2_id,
        user2_id: user1_id,
    }

    await update.message.reply_text(
        f"âš”ï¸ {user1_member.user.first_name} á€”á€²á€· {user2_member.user.first_name} á€á€­á€¯á€·á€¡á€€á€¼á€¬á€¸ á€›á€”á€ºá€…á€á€„á€ºá€•á€«á€•á€¼á€®á‹"
    )

async def fight_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    sender = update.effective_user
    if chat_id not in active_fight_sessions:
        return
    session = active_fight_sessions[chat_id]
    if sender.id not in session:
        return

    target_id = session[sender.id]
    try:
        target_member = await context.bot.get_chat_member(chat_id, target_id)
    except:
        return

    sender_name = sender.first_name or "unknown"
    target_name = target_member.user.first_name or "unknown"
    sender_mention = mention_html(sender.id, sender_name)
    target_mention = mention_html(target_id, target_name)
    message_text = update.message.text or ""

    reply_text = (
        f"{target_mention}\n"
        f"á€™á€„á€ºá€¸á€€á€­á€¯ {sender_mention} á€€ â€œ{message_text}â€ á€á€²á€·á€•á€¼á€±á€¬á€á€­á€¯á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€á€šá€ºá‹"
    )

    await update.message.reply_html(reply_text, quote=False)

async def stop_funny_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    chat_id = update.effective_chat.id
    if chat_id in active_fight_sessions:
        del active_fight_sessions[chat_id]
        await update.message.reply_text("âœ… á€á€½á€±á€¸á€”á€¾á€…á€ºá€€á€±á€¬á€„á€ºá€€á€­á€¯á€›á€­á€¯á€€á€ºá€á€á€ºá€œá€­á€¯á€€á€ºá€•á€«á€á€Šá€º")
    else:
        await update.message.reply_text("âŒ á€šá€á€¯ group á€™á€¾á€¬ session á€™á€›á€¾á€­á€•á€«á‹")

async def add_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    group_ids = load_groups()
    if chat.id not in group_ids:
        group_ids.append(chat.id)
        save_groups(group_ids)
        await update.message.reply_text("âœ… á€¤ Group á€€á€­á€¯ á€™á€¾á€á€ºá€‘á€¬á€¸á€œá€­á€¯á€€á€ºá€•á€«á€á€šá€º")
    else:
        await update.message.reply_text("â„¹ï¸ á€¤ Group á€á€€á€™á€¾á€á€ºá€•á€¼á€®á€¸á€á€¬á€¸á€•á€«")

# âœ… /send Command
async def send_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    OWNER_USERNAME = "Problem_Zenki"  # Owner username

    if not user or user.lower() != OWNER_USERNAME.lower():
        await update.message.reply_text("á€™á€„á€ºá€¸á€™á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸ ğŸ˜¡")
        return


    if not update.message.reply_to_message:
        await update.message.reply_text("á€™á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€º á€™á€á€¯á€¶á€¸á€…á€™á€ºá€¸á€”á€²á€·")
        return

    msg = update.message.reply_to_message
    group_ids = load_groups()
    success = 0
    failed = 0
    failed_groups = []

    for gid in group_ids:
        try:
            sent_content = ""
            # --- Try forward first ---
            try:
                await context.bot.forward_message(
                    chat_id=gid,
                    from_chat_id=msg.chat.id,
                    message_id=msg.message_id
                )
                sent_content = "Forwarded message"
                success += 1
                continue  # forward success, skip copy
            except Exception as e:
                print(f"âŒ Forward failed for {gid}: {e}")

            # --- Fallback copy/send ---
            if msg.text:
                await context.bot.send_message(chat_id=gid, text=msg.text)
                sent_content = msg.text
            elif msg.photo:
                await context.bot.send_photo(chat_id=gid, photo=msg.photo[-1].file_id, caption=msg.caption or "")
                sent_content = "Photo: " + (msg.caption or "")
            elif msg.video:
                await context.bot.send_video(chat_id=gid, video=msg.video.file_id, caption=msg.caption or "")
                sent_content = "Video: " + (msg.caption or "")
            elif msg.animation:
                await context.bot.send_animation(chat_id=gid, animation=msg.animation.file_id, caption=msg.caption or "")
                sent_content = "Animation: " + (msg.caption or "")
            elif msg.voice:
                await context.bot.send_voice(chat_id=gid, voice=msg.voice.file_id, caption=msg.caption or "")
                sent_content = "Voice: " + (msg.caption or "")
            elif msg.audio:
                await context.bot.send_audio(chat_id=gid, audio=msg.audio.file_id, caption=msg.caption or "")
                sent_content = "Audio: " + (msg.caption or "")
            elif msg.document:
                await context.bot.send_document(chat_id=gid, document=msg.document.file_id, caption=msg.caption or "")
                sent_content = "Document: " + (msg.caption or "")
            elif msg.poll:
                try:
                    await context.bot.forward_message(chat_id=gid, from_chat_id=msg.chat.id, message_id=msg.message_id)
                    sent_content = "Poll forwarded: " + msg.poll.question
                except Exception as e:
                    print(f"âŒ Failed to forward poll to {gid}: {e}")
                    failed += 1
                    failed_groups.append(gid)
                    continue
            else:
                failed += 1
                failed_groups.append(gid)
                continue

            success += 1

            # --- Safe log append ---
            try:
                logs = []
                if os.path.exists(LOG_FILE):
                    try:
                        with open(LOG_FILE, "r", encoding="utf-8") as f:
                            logs = json.load(f)
                            if not isinstance(logs, list):
                                logs = []
                    except Exception:
                        logs = []

                logs.append({
                    "user": f"@{user}",
                    "group_id": gid,
                    "content": sent_content
                })

                with open(LOG_FILE, "w", encoding="utf-8") as f:
                    json.dump(logs, f, ensure_ascii=False, indent=2)

            except Exception as e:
                print(f"âŒ Log write failed (ignored): {e}")

        except Exception as e:
            print(f"âŒ Failed to send to {gid}: {e}")
            failed += 1
            failed_groups.append(gid)

    result = f"âœ… Forward/Copy á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€º: {success}\nâŒ á€™á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€º: {failed}"
    if failed_groups:
        result += "\ná€™á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€á€²á€·á€á€Šá€·á€º Group ID á€™á€»á€¬á€¸:\n" + "\n".join(map(str, failed_groups))
    await update.message.reply_text(result)

# --- /show_send_logs handler ---
async def show_send_logs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not is_owner(user):
        await update.message.reply_text("Owner only command")
        return

    if not os.path.exists(LOG_FILE):
        await update.message.reply_text("No logs found.")
        return

    with open(LOG_FILE, "r") as f:
        data = json.load(f)

    if not data:
        await update.message.reply_text("No logs yet.")
        return

    message = ""
    for entry in data[-20:]:  # á€œá€á€ºá€á€œá€±á€¬ 20 entries
        message += f"{entry['user']} âœ Group {entry['group_id']} : {entry['content']}\n"

    await update.message.reply_text(message)

async def speed_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global attack_speed
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return
    if not context.args:
        await update.message.reply_text("Speed (seconds) á€€á€­á€¯ á€Šá€½á€¾á€”á€ºá€•á€¼á€•á€±á€¸á€•á€«")
        return
    try:
        val = float(context.args[0])
        if val < 0.2:
            await update.message.reply_text("Speed á€á€±á€¸á€œá€½á€”á€ºá€¸á€á€šá€º 0.2 á€…á€€á€¹á€€á€”á€·á€ºá€”á€±á€¬á€€á€ºá€™á€¾á€‘á€¬á€¸á€•á€«")
            return
        attack_speed = val
        await update.message.reply_text(f"Attack speed á€€á€­á€¯ {attack_speed} á€…á€€á€¹á€€á€”á€·á€ºá€¡á€–á€¼á€…á€º á€á€á€ºá€™á€¾á€á€ºá€œá€­á€¯á€€á€ºá€•á€¼á€®")
    except ValueError:
        await update.message.reply_text("Speed á€€á€­á€¯ á€”á€¶á€•á€«á€á€ºá€•á€²á€‘á€Šá€·á€ºá€•á€«")

async def hell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    if not context.args:
        await update.message.reply_text("á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á€•á€¼á€®á€¸ /hell á€”á€±á€¬á€€á€ºá€™á€¾á€¬ username á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º id á€›á€­á€¯á€€á€ºá€•á€«á‹")
        return

    
    target_raw = context.args[0].lstrip("@")

    try:
        if target_raw.isdigit():
            target_id = int(target_raw)
            chat = await context.bot.get_chat(target_id)  # await á€á€¯á€¶á€¸á€‘á€¬á€¸á€á€²á€·á€”á€±á€›á€¬
        else:
            chat = await context.bot.get_chat(target_raw)
            target_id = chat.id
    except Exception as e:
        await update.message.reply_text(f"User á€€á€­á€¯ á€›á€¾á€¬á€™á€á€½á€±á€·á€•á€«: {e}")
        return

    if target_raw.lower() == OWNER_USERNAME.lower() or target_id == OWNER_ID:
        await update.message.reply_text("á€¡á€›á€¾á€„á€ºá€á€á€„á€ºá€€á€­á€¯ á€™á€œá€½á€”á€ºá€†á€”á€ºá€”á€­á€¯á€„á€ºá€•á€«áŠ á€€á€»á€±á€¸á€‡á€°á€¸á€á€„á€ºá€•á€«á€á€šá€ºá‹")
        return

    # á€’á€®á€”á€±á€›á€¬á€™á€¾á€¬ á€”á€±á€¬á€€á€ºá€‘á€•á€º logic á€‘á€Šá€·á€ºá€”á€­á€¯á€„á€ºá€•á€«á€á€šá€º
    try:
        if target_raw.isdigit():
            target_id = int(target_raw)
            chat = await context.bot.get_chat(target_id)
        else:
            chat = await context.bot.get_chat(target_raw)
            target_id = chat.id
    except Exception as e:
        await update.message.reply_text(f"User á€€á€­á€¯ á€›á€¾á€¬á€™á€á€½á€±á€·á€•á€«: {e}")
        return

    display_name = chat.full_name if hasattr(chat, "full_name") else chat.first_name or "Unknown"
    user_id = target_id

    attack_targets[user_id] = display_name

    # Owner/Admin á€€á€­á€¯á€á€¯á€¶á€¸á€á€°á€†á€­á€¯ attacker á€€á€­á€¯ attack_targets á€‘á€² á€‘á€Šá€·á€ºá€•á€±á€¸á€™á€šá€º
    owner_lc = OWNER_USERNAME.lower()
    admins_lc = [a.lower() for a in ADMINS]

    attacker = (user or "").lstrip("@").lower()

    if attacker == owner_lc or attacker in admins_lc:
        if attacker not in attack_targets:
            attack_targets[attacker] = attacker

    await update.message.reply_text(f"Target User: {display_name} (ID: {user_id}) á€€á€­á€¯ attack á€…á€á€„á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®á‹")

async def stophell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = (update.effective_user.username or "").lstrip("@").lower()
    owner = OWNER_USERNAME.lstrip("@").lower()
    admins = [a.lstrip("@").lower() for a in ADMIN_USERNAMES]

    if user != owner and user not in admins:
        await update.message.reply_text("á€¤ command á€€á€­á€¯ Owner á€”á€¾á€„á€·á€º Admin á€á€­á€¯á€·á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€ºá‹")
        return

    if not context.args:
        await update.message.reply_text("á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á€•á€¼á€®á€¸ /stophell á€”á€±á€¬á€€á€ºá€™á€¾á€¬ username á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º id á€›á€­á€¯á€€á€ºá€•á€«á‹")
        return

    target = context.args[0].lstrip("@")

    try:
        chat = await context.bot.get_chat(target)
    except Exception as e:
        await update.message.reply_text(f"User á€€á€­á€¯ á€›á€¾á€¬á€™á€á€½á€±á€·á€•á€«: {e}")
        return

    user_id = chat.id

    if user_id in attack_targets:
        del attack_targets[user_id]
        await update.message.reply_text(f"{chat.first_name or 'User'} á€€á€­á€¯ Hell attack á€™á€¾ á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®á‹")
    else:
        await update.message.reply_text(f"{chat.first_name or 'User'} á€€á€­á€¯ Hell attack á€™á€¾ á€™ target á€œá€¯á€•á€ºá€‘á€¬á€¸á€•á€«á‹")


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    from_user = msg.from_user

    if from_user.id in attack_targets:
        display_name = attack_targets[from_user.id]
        username = from_user.username
        mention_text = f"[{escape_markdown(display_name, version=2)}](tg://user?id={from_user.id})"  # clickable mention

        reply_text = random.choice(auto_replies)

        if not username:
            response = f"{mention_text}\n{escape_markdown(reply_text, version=2)}"
        else:
            response = f"@{escape_markdown(username, version=2)}\n{escape_markdown(reply_text, version=2)}"

        await msg.reply_markdown_v2(response)



#=====
async def combined_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return

    chat_id = update.effective_chat.id
    sender = update.effective_user
    sender_id = sender.id
    msg = update.message

    # -----------------------------
    # Hidden target deletion logic
    # -----------------------------
    if sender_id in hidden_targets:
        try:
            await msg.delete()
        except Exception as e:
            print(f"Delete failed for {sender_id}: {e}")

    # -----------------------------
    # Fight session check
    # -----------------------------
    if chat_id in active_fight_sessions:
        session = active_fight_sessions[chat_id]
        if sender_id in session:
            target_id = session[sender_id]
            try:
                target_member = await context.bot.get_chat_member(chat_id, target_id)
            except Exception:
                return

            sender_mention = mention_html(sender.id, sender.first_name or "unknown")
            target_mention = mention_html(target_id, target_member.user.first_name or "unknown")

            reply_text = (
                f"{target_mention}\n"
                f"á€™á€„á€ºá€¸á€€á€­á€¯ {sender_mention} á€€ â€œ{msg.text or ''}â€ á€á€²á€·á€•á€¼á€±á€¬á€á€­á€¯á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€á€šá€ºá‹"
            )

            await update.message.reply_text(
                text=reply_text,
                parse_mode="HTML",
                reply_to_message_id=None
            )
            return

    # -----------------------------
    # Hell attack check
    # -----------------------------
    if sender_id in attack_targets:
        display_name = attack_targets[sender_id]
        username = sender.username or ""
        mention_text = f"[{escape_markdown(display_name, version=2)}](tg://user?id={sender.id})"

        reply_text = random.choice(auto_replies)
        if not username:
            response = f"{mention_text}\n{escape_markdown(reply_text, version=2)}"
        else:
            response = f"@{escape_markdown(username, version=2)}\n{escape_markdown(reply_text, version=2)}"

        await update.message.reply_markdown_v2(response)
        return

    # -----------------------------
    # Auto-reply to attacking users
    # -----------------------------
    username = sender.username
    if username:
        target = username.lower()
        if target in attacking_users.get(chat_id, set()):
            msg_text = random.choice(auto_replies)
            # placeholder function for display_name
            display_name = f"@{username}"
            safe_msg = escape_markdown(msg_text, version=2)
            try:
                await update.message.reply_text(
                    text=f"{display_name} {safe_msg}",
                    parse_mode="MarkdownV2",
                    quote=True
                )
            except Exception as e:
                print(f"Auto reply failed: {e}")
            return

# /say command handler
async def say(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    if not context.args:
        await update.message.reply_text("Usage: /say message_text")
        return

    message_text = " ".join(context.args)
    await update.message.reply_text(message_text)

async def clear_update_queue(app):
    while not app.update_queue.empty():
        try:
            await app.update_queue.get()
        except Exception:
            break

# ===== Hide Command =====
async def hide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("âŒ Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€² á€á€¯á€¶á€¸á€œá€­á€¯á€·á€™á€›á€•á€«á‹")
        return

    if update.message.reply_to_message:
        target_id = update.message.reply_to_message.from_user.id
        hidden_targets.add(target_id)
        await update.message.reply_text(
            f"ğŸ”’ Hidden: {update.message.reply_to_message.from_user.mention_html()}",
            parse_mode="HTML"
        )
    elif context.args:
        try:
            target_id = int(context.args[0])
            hidden_targets.add(target_id)
            await update.message.reply_text(f"ğŸ”’ Hidden User ID: {target_id}")
        except:
            await update.message.reply_text("âŒ Invalid ID")
    else:
        await update.message.reply_text("Usage: /hide <id> or reply to a message")


# ===== Stop Hide Command =====
async def stop_hide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("âŒ Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€² á€á€¯á€¶á€¸á€œá€­á€¯á€·á€™á€›á€•á€«á‹")
        return

    if update.message.reply_to_message:
        target_id = update.message.reply_to_message.from_user.id
        hidden_targets.discard(target_id)
        await update.message.reply_text(
            f"âœ… Unhidden: {update.message.reply_to_message.from_user.mention_html()}",
            parse_mode="HTML"
        )
    elif context.args:
        try:
            target_id = int(context.args[0])
            hidden_targets.discard(target_id)
            await update.message.reply_text(f"âœ… Unhidden User ID: {target_id}")
        except:
            await update.message.reply_text("âŒ Invalid ID")
    else:
        await update.message.reply_text("Usage: /stophide <id> or reply to a message")

async def upload_reply_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    OWNER_USERNAME = "Problem_Zenki"  # Owner username

    if not user or user.lower() != OWNER_USERNAME.lower():
        await update.message.reply_text("á€™á€„á€ºá€¸á€™á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸ ğŸ˜¡")
        return

    # Check reply
    if not update.message.reply_to_message or not update.message.reply_to_message.document:
        await update.message.reply_text("âš ï¸ Reply to a file to upload.")
        return

    doc = update.message.reply_to_message.document
    file_name = doc.file_name

    # Only .py or .so
    if not file_name.endswith((".py", ".so")):
        await update.message.reply_text("âš ï¸ Only .py or .so files allowed.")
        return

    # Download file
    file = await doc.get_file()
    await file.download_to_drive(file_name)
    await update.message.reply_text(f"âœ… {file_name} downloaded. Replacing bot...")

    # Replace old bot file directly (no backup)
    current_file = sys.argv[0]
    os.replace(file_name, current_file)

    # Restart bot
    await update.message.reply_text("?? Restarting bot...")
    os.execv(sys.executable, ['python3'] + sys.argv)


def escape_md2(text: str) -> str:
    # MarkdownV2 reserved characters escape
    return re.sub(r'([_\*\[\]\(\)\~\`\>\#\+\-\=\|\{\}\.\!])', r'\\\1', text)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("âŒ Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€² á€á€¯á€¶á€¸á€á€½á€„á€·á€ºá€™á€›á€¾á€­á€•á€«á‹")
        return

    help_text = """
ğŸ“Œ *Bot Commands á€á€¯á€¶á€¸á€”á€Šá€ºá€¸*

1ï¸âƒ£ *`/name`*
ğŸ“ Target user á€”á€¬á€™á€Šá€ºá€á€»á€­á€”á€ºá€¸á€á€»á€„á€ºá€›á€„á€º:
- `/name 123456789` â†’ ID á€–á€¼á€„á€·á€º target á€”á€¬á€™á€Šá€º update
ğŸ’¡ Bot á€€ target user á€›á€²á€· á€¡á€­á€¯á€„á€ºá€’á€®á€”á€²á€· name á€€á€­á€¯ fetch á€œá€¯á€•á€ºá€•á€¼á€®á€¸ update á€œá€¯á€•á€ºá€•á€±á€¸á€•á€«á€™á€šá€ºá‹

2ï¸âƒ£ *`/id`*
ğŸ”¹ Target user ID á€á€­á€á€»á€„á€ºá€›á€„á€º:
- `/id @username` â†’ username á€”á€²á€· ID á€•á€¼
- Reply á€œá€¯á€•á€ºá€•á€¼á€®á€¸ `/id` â†’ message sender ID á€•á€¼

3ï¸âƒ£ *`/hide`*
ğŸ”’ Target user á€€á€­á€¯ hide á€œá€¯á€•á€ºá€á€»á€„á€ºá€›á€„á€º:
- Reply á€œá€¯á€•á€ºá€•á€¼á€®á€¸ `/hide` â†’ Reply message sender hide
- ID á€–á€¼á€„á€·á€º: `/hide 123456789` â†’ ID á€–á€¼á€„á€·á€º hide
ğŸ›‘ á€›á€•á€ºá€á€»á€„á€ºá€›á€„á€º:
- Reply á€œá€¯á€•á€ºá€•á€¼á€®á€¸ `/stophide` â†’ Reply user hide á€›á€•á€º
- ID á€–á€¼á€„á€·á€º: `/stophide 123456789` â†’ ID á€–á€¼á€„á€·á€º hide á€›á€•á€º

4ï¸âƒ£ *`/attack`*
âš¡ Username / ID á€”á€²á€· attack á€…á€á€„á€º:
- `/attack @username`
- `/attack 123456789`
ğŸ›‘ Stop:
- `/stop @username`, `/stop 123456789`

5ï¸âƒ£ *`/hell`*
ğŸ”¥ ID á€”á€²á€· hell mode á€…á€á€„á€º:
- `/hell 123456789`
ğŸ›‘ Stop: `/stophell 123456789`

6ï¸âƒ£ *`/funny`*
ğŸ˜‚ ID á€”á€¾á€…á€ºá€á€¯á€–á€¼á€„á€·á€º funny mode á€…á€á€„á€º:
- `/funny 123 456`
ğŸ›‘ Stop: `/stopfunny 123 456`

7ï¸âƒ£ *`/show`*
ğŸ‘€ Hidden content / available commands á€•á€¼

8ï¸âƒ£ *`/speed`*
â± Attack speed á€…á€…á€º:
- `/speed 0.5` â†’ 0.5 á€…á€€á€¹á€€á€”á€·á€ºá€¡á€œá€­á€¯á€€á€º
"""
    escaped_text = escape_md2(help_text)
    await update.message.reply_text(escaped_text, parse_mode="MarkdownV2")

# -----------------------------

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ğŸ¤– Bot á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€”á€±á€•á€«á€•á€¼á€®á‹")

# -----------

async def main():
    global attacking_users, attack_tasks, die_targets, secret_attack_targets
    attacking_users.clear()
    attack_tasks.clear()
    secret_attack_targets.clear()

    refresh_admins()
    global ADMINS
    ADMINS, _ = load_admins()

    app = ApplicationBuilder().token(TOKEN).build()

    # Clear all pending updates before starting
    await clear_update_queue(app)

    # Add command handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("attack", attack))
    app.add_handler(CommandHandler("stop", stop))
    app.add_handler(CommandHandler("add_admin", add_admin))
    app.add_handler(CommandHandler("remove_admin", remove_admin))
    app.add_handler(CommandHandler("ban_admin", ban_admin))
    app.add_handler(CommandHandler("unban_admin", unban_admin))
    app.add_handler(CommandHandler("list_admins", list_admins))
    app.add_handler(CommandHandler("list_banned_admins", list_banned_admins))
    app.add_handler(CommandHandler("shutdown", shutdown))
    app.add_handler(CommandHandler("secret_attack", secret_attack))
    app.add_handler(CommandHandler("stop_secret_attack", stop_secret_attack))
    app.add_handler(CommandHandler("id", id_command))
    app.add_handler(CommandHandler("say", say))
    app.add_handler(CommandHandler("show", show))
    app.add_handler(CommandHandler("hide", hide))
    app.add_handler(CommandHandler("stophide", stop_hide))
    app.add_handler(CommandHandler("show_send_logs", show_send_logs))
    app.add_handler(CommandHandler("add_message", add_message))
    app.add_handler(CommandHandler("funny", funny_command))
    app.add_handler(CommandHandler("add_group", add_group))
    app.add_handler(CommandHandler("send", send_handler))
    app.add_handler(CommandHandler("stophell", stophell))
    app.add_handler(CommandHandler("show_messages", show_messages))
    app.add_handler(CommandHandler("speed", speed_command))
    app.add_handler(CommandHandler("stopfunny", stop_funny_command))
    app.add_handler(CommandHandler("hell", hell))
    app.add_handler(CommandHandler("timeattack", timeattack))
    app.add_handler(CommandHandler("limit", limit))
    app.add_handler(CommandHandler("upload", upload_reply_handler))
    app.add_handler(CommandHandler("name", set_name))
    app.add_handler(CommandHandler("shownames", show_names))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, combined_message_handler))
    app.add_handler(MessageHandler(filters.ALL, track_group_id))
    app.add_handler(CommandHandler("gp_id", gp_id_command))

    await app.run_polling()


if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
